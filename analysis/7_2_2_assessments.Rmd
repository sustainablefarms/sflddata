---
title: "Assessment of 7_2_2 detection only"
author: "Kassel Hingee"
date: "02/06/2020"
output: 
  html_document: 
    collapsed: no
    number_sections: yes
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tibble)
library(dplyr)
library(MCMCpack)
library(mclust)
library(corrplot)
library(coda)
library(runjags)
library(ggplot2)
library(patchwork)
```

```{r varname2type}
devtools::load_all() #load the sustfarmld package
varname2type <- function(varnames){
  types <- case_when(
    grepl("lv.coef", varnames) ~ "LV Load",
    grepl("LV", varnames) ~ "LV",
    grepl("^(mu|tau)", varnames) ~ "Comm Param", #parameters of community distributions
    grepl("^u.b", varnames) ~ "Occu Coef",
    grepl("^v.b", varnames) ~ "Detn Coef",
    TRUE ~ "other"
    )
  return(types)
}
```

## Data Import

```{r importdata, echo = FALSE, include = FALSE}
inputdata <- readRDS("./private/data/clean/7_2_1_input_data.rds")
detcovar <- model.matrix(~ ModelSiteID + MeanWind * MeanTime * MeanClouds * MeanTemp * ObserverId - 1,
             data = inputdata$plotsmerged_detection) %>%
  as_tibble() %>% rename(ModelSite = ModelSiteID)
```
```{r importmodelfits, out.width=14}
filenames <- list(
  wind = "./tmpdata/deto_wind.rds",
  wind_June4 =  "./tmpdata/deto_wind_June4.rds",
  time = "./tmpdata/deto_time.rds",
  windtime = "./tmpdata/deto_windtime.rds",
  windtemp = "./tmpdata/deto_windtemp.rds",
  windtemp_time = "./tmpdata/deto_windtemp_time.rds",
  windtimetemp_clouds = "./tmpdata/windtimetemp_clouds.rds",
  windtimeclouds_temp = "./tmpdata/windtimeclouds_temp_June4.rds",
  windtimecloudstemp = "./tmpdata/windtimecloudstema_June4.rds",
  clouds_time_temp_wind = "./tmpdata/deto_clouds_time_temp_wind.rds",
  timetemp = "./tmpdata/deto_timetemp.rds",
  interactions_2nd_nolv = "./tmpdata/deto_interactions_2nd.rds",
  clouds = "./tmpdata/deto_clouds.rds",
  temp = "./tmpdata/deto_temp.rds"
)

# test loading models
a <- vapply(filenames, file.exists, FUN.VALUE = FALSE)
stopifnot(all(a))

# load and remove crosscorrelation
fittedmods <- lapply(filenames, function(x) {
  fit <- readRDS(x)
  fit$crosscorr <- NULL
  return(fit)})

lapply(fittedmods, function(x) {
  if (!is.null(x$timetaken)) {return(runjags::timestring(as.numeric(x$timetaken, units="secs")))}
  else return(NULL)})
```

The time required for MCMC is very different, even with the same number of parameters (windtemp vs windtime). What is happening there?

I fear how long the more complicated models will take.
A model (the `7_2_1_mcmcchain_20200524` model in fact) with 3767 visits, 2097 ModelSites, 81 species, 5 detection covariates, 6 occupancy covariates and 2 latent variables took 4.8 days to complete MCMC.
It had adapt = 4000, burnin = 30000, sample = 2000, thin = 50. Adapting could be much shorter, smaller samples, and possibly smaller burning and thinning.

## MCMC Assessment
### Autocorrelation 
```{r autocorr_fromsummary}
mergedsummaries <- bind_rows(lapply(fittedmods, function(x) as_tibble(x$summaries, rownames = "varname")),
                             .id = "Model") %>%
  mutate(AC_10 = case_when(
    is.finite(AC.300) ~ AC.300,
    is.finite(AC.400) ~ AC.400,
    TRUE ~ as.numeric(NA)))
mergedsummaries %>%
  mutate(type = varname2type(varname)) %>%
  ggplot() +
  facet_grid(rows = vars(type), cols = vars(Model), scales = "free_y") +
  geom_histogram(aes(x = AC_10), bins = 30) +
  geom_vline(aes(xintercept = 0.1), col = "red") +
  scale_y_continuous(name = "Number of Parameters")
```

There was a lot of autocorrelation in the LV loadings and some in the occupancy coefficients. There was also a small amount of autocorrelation in the detection coefficients of the WindTime model. **why?** 
Some have autocorrelation above 0.5!
There is a lot of autocorrelation between the parameters at the given thinning rate of 30. Even parameters that aren't related to the latent variables.
This might mean the models take too long to fit for us to use in our work. Or that prototype models with fewer samples must be used.

The comprehensive model contained excessive amounts of autocorrelation in the detection coefficients. I suspect it is not worth assessing it futher.

In the detection coefficients, the following models appear to have an acceptable amount of autocorrelation:
clouds, clouds_time_temp_wind, temp, time, wind, windtemp, windtemp_time, windtime.


### Convegence (Geweke)
See http://www.ugrad.stat.ubc.ca/R/library/coda/html/geweke.diag.html for a very quick description of this.
The Geweke values are Z-scores.
95% of (independent) Geweke values should be within 2 standard deviations (i.e. just 2 for Z-scores) of the mean.

```{r gewekesumm}
gwk <- bind_rows(lapply(fittedmods, 
       function(x) enframe(geweke.diag(x, frac1=0.1, frac2=0.5)$z, name = "varname")),
       .id = "Model")
gwk %>%
  mutate(type = varname2type(varname)) %>%
  ggplot() +
  facet_grid(rows = vars(type), cols = vars(Model)) +
  geom_abline(slope = 1, intercept = 0, lty = "dashed") +
  geom_qq(aes(sample = value), shape = "+", size = 2) +
  coord_cartesian(ylim = c(-5, 5))
```

Geweke values look ok for community parameters, detection coefficients and occupancy coefficients, except for windtimeclouds_temp and windtimecloudstemp, which both have poor Geweke values for detection coefficients.
The Geweke values for LV values for `windtemp` (wind * temp) look a bit poor.
The Geweke values for the LV loadings are all much poorer, particularly with `windtemp` model.

```{r swstatistics, rows.print = 14}
gwk %>%
  mutate(type = varname2type(varname)) %>%
  group_by(Model, type) %>%
  summarise(swp = shapiro.test(value)$p.value) %>%
  ggplot() +
  facet_wrap(~type) +
  geom_vline(aes(xintercept = 0.01)) +
  geom_point(aes(y = Model, x = swp, col = Model)) + 
  scale_x_continuous(name = "Shapiro-Wilk p-value",
                     trans = "sqrt")
```

The Geweke Diagnostics *should* be normally distributed. Poor convergence is suggested by low Shaprio-Wilk p-values.

We are interested in assessing the models using latent variable loadings and detection coefficients. Warton et al (2015; Figure 2) use distance from the origin of the factor loadings to choose species with interesting correlations to display.
The LV loadings inform the correlation between detections that is unexplained by the covariates, assuming the residuals pass the checks. As all the models appear to predict detection equally well, higher average LV loadings suggest poorer explanation by covariates (on average).

Models with converged LV loadings (as indicated by the Geweke scores) were:
windtemp_time, wind, timtemp, temp, clouds_time_temp_wind, clouds.
However, note that the LV loadings display lots of autocorrelation.

### Conclusions
The windtimeclouds_temp and windtimecloudstemp models did not converge and had too much autocorrelation in the detection coefficients to be useful.

Wind_June4 is not need for further analysis.

**Convergence:** The LV coefficients for `windtemp` and `wind` did not converge, and the LV values for `windtemp` did not converge. Everything else appears to have converged nicely.
Detection coefficients for windtimeclouds_temp and windtimecloudstemp did not converge, it is not worth assessing these two fitted objects further.

Wind_June4 used fewer burnins, adaptions and pulled out few samples It was 50% faster than the original Wind fit. However, it has converged nicely.

**Autocorrelation:**
There was a lot of autocorrelation in the LV loadings and some in the occupancy coefficients. There is a small amount of autocorrelation in the detection coefficients. The thinning rate of 30 may be too small.
Autocorrelation for the windtimecloudstemp model is too high to be usable.

**Models with acceptable detection coefficient autocorelation, and acceptable LV loading convergence (all have too high LV loading autocorrelation):**
Clouds, clouds_time_temp_wind, temp, wind, windtemp_time.

## Model Diagnostics (Residuals etc)
### Wind Only Model
Plots: occupancy residuals, LVs, detection residuals against every covariate.
Include Min of MeanTime, to assess the outliers in visit time.

```{r windresidualscompute}
library(sustfarmld)
resid_det <- ds_detection_residuals.fit(fittedmods[["wind"]], type = "median", seed = 321)
resid_occ <- ds_occupancy_residuals.fit(fittedmods[["wind"]], type = "median", conditionalLV = TRUE, seed = 321)
```

#### Not Species Specific
```{r wind_vs_latentvariables, fig.height=15, fig.width=30}
plot_LVvscovar.fit(fittedmods[["wind"]], covar = detcovar, aggregatefcn = mean) + scale_x_continuous(name = "Mean Site Covariate Value")
plot_LVvscovar.fit(fittedmods[["wind"]], covar = detcovar, aggregatefcn = min) + scale_x_continuous(name = "Min Site Covariate Value")
plot_LVvscovar.fit(fittedmods[["wind"]], covar = detcovar, aggregatefcn = max) + scale_x_continuous(name = "Max Site Covariate Value")
```

__Mean of Covariates:__
Suggests MeanTime, MeanWind (2nd order perhaps?), MeanClouds,
MeanClouds:MeanTemp,
MeanTemp, 
MeanTime:MeanClouds,
MeanTime:MeanTemp,
MeanWind:MeanTime.

ObserverId is also suggested as having a systematic effect - perhaps larger observer ID corresponds to more recent observations?

__Min of Covariates:__
The outlying observation times (Min of MeanTime) did not have overly high residuals. Suggesting that my imputation, using the site's mean visit time, has worked ok.

MeanWind appears to want a higher order effect.

Min of MeanTime appears strongly associates to LV2.

__Max of Covariates:__
Nothing of further to note. Everything appears consistent with the Mean and Min plots.

```{r wind_resid_covars, fig.height=12, fig.width=30}
# 3 plots: occupancy residuals, LVs, detection residuals
plot_residuals.residual(resid_det, detcovar, plotfunction = facet_covariate) + scale_y_continuous(name = "Detection Residual") + coord_cartesian(ylim = c(-0.5, 0.5))
plot_residuals.residual(resid_occ, detcovar, plotfunction = facet_covariate) + scale_y_continuous(name = "Occupancy Residual") + coord_cartesian(ylim = c(-0.1, 0.1))
```

Only suggested extra covariate is ObserverId. Nothing else is suggested by the detection and occupancy residuals marginalised across species.



#### By Species Residuals
```{r wind_v_wind_byspecies, fig.height=12, fig.width=30}
# detcovar_sel <- detcovar %>% dplyr::select(ModelSite, MeanWind, MeanTime, MeanClouds, "MeanClouds:MeanTemp")
plot_residuals.residual(resid_det, detcovar %>% dplyr::select(ModelSite, MeanWind)) + 
  coord_cartesian(ylim = c(-0.5, 0.5)) + scale_y_continuous(name = "Detection Residual") 
plot_residuals.residual(resid_occ,  detcovar %>% dplyr::select(ModelSite, MeanWind)) + 
  coord_cartesian(ylim = c(-0.1, 0.1)) + scale_y_continuous(name = "Occupancy Residual")
plot_residuals.residual(resid_occ,  detcovar %>% dplyr::select(ModelSite, MeanWind), aggregatefcn = min) + 
  coord_cartesian(ylim = c(-0.1, 0.1)) + scale_y_continuous(name = "Occupancy Residual") + scale_x_continuous(name = "Site Min of Covariate Value")
plot_residuals.residual(resid_occ,  detcovar %>% dplyr::select(ModelSite, MeanWind), aggregatefcn = max) + 
  coord_cartesian(ylim = c(-0.1, 0.1)) + scale_y_continuous(name = "Occupancy Residual") + scale_x_continuous(name = "Site Max of Covariate Value")
```

__MeanWind:__ Little Friarbird, Spotted Pardalote and Leaden Flycatcher appear to be unusually influencd by MeanWind, but only through a particularly large offset. I suspect the cause of these large residuals would be the community distribution placed upon covariate loadings.

Grey Shrike-Thrush, Brown-headed Honeyeater, Yellow Thornbill all have occupancy residuals that are related to MeanWind. Note the occupancy residuals incorporate the fitted LV. This suggests more LVs would give more information on the missing ModelSite information. It also suggests that, possibly, detection for these creatures was so hard in winds of 2 and higher that they were estimated as not being in occupation. It appeared that the Site Minimum of wind was also strongly related to these birds occupancy residuals.


```{r wind_v_time_byspecies, fig.height=12, fig.width=30}
plot_residuals.residual(resid_det, detcovar %>% dplyr::select(ModelSite, MeanTime)) + 
  coord_cartesian(ylim = c(-0.5, 0.5)) + scale_y_continuous(name = "Detection Residual") 
plot_residuals.residual(resid_occ,  detcovar %>% dplyr::select(ModelSite, MeanTime)) + 
  coord_cartesian(ylim = c(-0.1, 0.1)) + scale_y_continuous(name = "Occupancy Residual")

plot_residuals.residual(resid_det, detcovar %>% dplyr::select(ModelSite, MeanClouds)) + 
  coord_cartesian(ylim = c(-0.5, 0.5)) + scale_y_continuous(name = "Detection Residual") 
plot_residuals.residual(resid_occ,  detcovar %>% dplyr::select(ModelSite, MeanClouds)) + 
  coord_cartesian(ylim = c(-0.1, 0.1)) + scale_y_continuous(name = "Occupancy Residual")

plot_residuals.residual(resid_det, detcovar %>% dplyr::select(ModelSite, "MeanClouds:MeanTemp")) + 
  coord_cartesian(ylim = c(-0.5, 0.5)) + scale_y_continuous(name = "Detection Residual") 
plot_residuals.residual(resid_occ,  detcovar %>% dplyr::select(ModelSite, "MeanClouds:MeanTemp")) + 
  coord_cartesian(ylim = c(-0.1, 0.1)) + scale_y_continuous(name = "Occupancy Residual")
```

MeanTime appeared unrelated to detection residuals for every species, but was related to the magpie's occupancy residuals.

Similarly MeanClouds, with the exception of the Australian Magpie. A few birds (Common Bronzewing, Masked Woodswallow) show some effects.

Similarly for MeanClouds:MeanTemp. Impacts of this interaction do not seem very large. Only the Australian Magpie and the Red Rumped parrot have non-zero residuals, and only Occupancy residuals.

### WindTime
```{r windtime_residualscompute}
resid_det <- ds_detection_residuals.fit(fittedmods[["windtime"]], type = "median", seed = 123)
resid_occ <- ds_occupancy_residuals.fit(fittedmods[["windtime"]], type = "median", conditionalLV = TRUE, seed = 123)
```

#### Not Species Specific
```{r windtime_vs_latentvariables, fig.height=15, fig.width=30}
plot_LVvscovar.fit(fittedmods[["windtime"]], covar = detcovar, aggregatefcn = mean) + scale_x_continuous(name = "Mean Site Covariate Value")
plot_LVvscovar.fit(fittedmods[["windtime"]], covar = detcovar, aggregatefcn = min) + scale_x_continuous(name = "Min Site Covariate Value")
plot_LVvscovar.fit(fittedmods[["windtime"]], covar = detcovar, aggregatefcn = max) + scale_x_continuous(name = "Max Site Covariate Value")
```

LV1 is not related to any of the site means of the covariates. There is possibly a relation to MeanWind.
LV2 seems to have relations to MeanClouds, MeanTemp and ObserverId in the site means.
LV2 is strongly related to site minimum of MeanTime --> this suggests including MeanTime^2.
LV2 smoothed is non-zero for site maximimums of MeanClouds, MeanTemp, and MeanTime.

As this model already has MeanWind and MeanTime included as detection covariates, the LVs suggest to include MeanTime^2 and possibly MeanWind^2. They also suggest to include MeanClouds and MeanTemp. These plots do not seem able to indicate whether are interactions with MeanClouds or MeanTemp. The shapes suggest to include MeanClouds^2 and MeanTemp^2.

```{r windtime_resid_covars, fig.height=12, fig.width=30}
# 3 plots: occupancy residuals, LVs, detection residuals
plot_residuals.residual(resid_det, detcovar, plotfunction = facet_covariate) + scale_y_continuous(name = "Detection Residual") + coord_cartesian(ylim = c(-0.5, 0.5))
plot_residuals.residual(resid_occ, detcovar, plotfunction = facet_covariate) + scale_y_continuous(name = "Occupancy Residual") + coord_cartesian(ylim = c(-0.1, 0.1))
```

Detection residuals are related to MeanWind, suggesting, like the LVs to include MeanWind^2.
Occupancy residuals do not suggest much.


### WindTemp + Time
```{r windtemp_time_residualscompute}
resid_det <- ds_detection_residuals.fit(fittedmods[["windtemp_time"]], type = "median", seed = 123)
resid_occ <- ds_occupancy_residuals.fit(fittedmods[["windtemp_time"]], type = "median", conditionalLV = TRUE, seed = 123)
```

#### Not Species Specific
```{r windtemp_time_vs_latentvariables, fig.height=15, fig.width=30}
plot_LVvscovar.fit(fittedmods[["windtemp_time"]], covar = detcovar, aggregatefcn = mean) + scale_x_continuous(name = "Mean Site Covariate Value")
plot_LVvscovar.fit(fittedmods[["windtemp_time"]], covar = detcovar, aggregatefcn = min) + scale_x_continuous(name = "Min Site Covariate Value")
plot_LVvscovar.fit(fittedmods[["windtemp_time"]], covar = detcovar, aggregatefcn = max) + scale_x_continuous(name = "Max Site Covariate Value")
```

LV1 is related to site means of nothing.
LV2 is related to site means of MeanClouds, MeanTemp, MeanTime. The former two appear to be non-linear.

LV1 is related to site minimums of MeanWind.
LV2 is related to site minimums of MeanTemp (non-linear) and MeanTime.

LV1 is related to site maximums of Nothing.
LV2 is related to site maximums of MeanClouds (non-linear) and MeanTemp (nonlinear).

This model already has temperature, time and wind. The above suggests including MeanTemp^2, MeanClouds^2 and MeanTime^2.

```{r windtemp_time_resid_covars, fig.height=12, fig.width=30}
# 3 plots: occupancy residuals, LVs, detection residuals
plot_residuals.residual(resid_det, detcovar, plotfunction = facet_covariate) + scale_y_continuous(name = "Detection Residual") + coord_cartesian(ylim = c(-0.5, 0.5))
plot_residuals.residual(resid_occ, detcovar, plotfunction = facet_covariate) + scale_y_continuous(name = "Occupancy Residual") + coord_cartesian(ylim = c(-0.1, 0.1))
```

No relations to covariates in the detection or occupancy residuals.

#### LV 2nd Order Plots
```{r windtemp_time_lvs_interactions}
covar2nd <- model.matrix(~ ModelSiteID + MeanWind + MeanTime + MeanClouds + MeanTemp - 1,
             data = inputdata$plotsmerged_detection) %>%
  as_tibble() %>% rename(ModelSite = ModelSiteID)

# df <- plotdf_LVvscovar.fit(fittedmods[["windtemp_time"]],
#                    covar = detcovar %>% dplyr::select(ModelSite, MeanClouds, MeanTemp))

# df %>%
#    mutate(MeanTempBin = case_when(
#      MeanTemp > 20 ~ "hot",
#      MeanTemp > 10 ~ "mild",
#      TRUE ~ "cool"
#    )) %>%
#   # mutate(MeanTempBin = cut(MeanTemp, 3)) %>%
#   pivot_longer(starts_with("LV"), names_to = "LV Name", values_to = "LV Value") %>%
#   pivot_longer(matches("MeanClouds"), names_to = "Covariate Name", values_to = "Covariate Value") %>%
#   ggplot() +
#     geom_point(aes(y = `LV Value`, x = `Covariate Value`, col = MeanTempBin)) +
#     facet_wrap(vars(`LV Name`, `Covariate Name`), scales = "free") +
#     geom_hline(yintercept = 0, col = "grey", lty = "dashed") +
#     geom_smooth(aes(x = `Covariate Value`, y = `LV Value`, col = MeanTempBin), method = "gam", level = 0.95, formula = y ~ s(x, bs = "cs")) 

plot_LVvscovar.fit(fittedmods[["windtemp_time"]],
                   covar = detcovar %>% dplyr::select(ModelSite, MeanClouds, MeanTime, MeanWind, MeanTemp),
                   facetvars = "MeanTemp",
                   cuts = c(0, 10, 20, 35)) +
  coord_cartesian(ylim = c(-1, 1))

plot_LVvscovar.fit(fittedmods[["windtemp_time"]],
                   covar = detcovar %>% dplyr::select(ModelSite, MeanClouds, MeanTime, MeanWind),
                   facetvars = "MeanWind",
                   cuts = c(0.9, 1.5, 2, 3, 4.1))

plot_LVvscovar.fit(fittedmods[["windtemp_time"]],
                   covar = detcovar %>% dplyr::select(ModelSite, MeanClouds, MeanTime),
                   facetvars = "MeanTime",
                   cuts = 4)
```

First Plot: 
There appears to be differences in the relation between LV2 and MeanClouds, LV1 and MeanTime, LV2 and MeanTime, LV2 and MeanWind at cool temperatures, verses other temperatures. This suggests that these interactions terms could be useful in the model.

Second Plot:
MeanTime and MeanWind interact in their relation of LVs.

Third Plot:
MeanTime and MeanClouds interact in their relation to LV2.

#### Species Specific Residuals
```{r windtemp_time_v_clouds_byspecies, fig.height=12, fig.width=30}
# detcovar_sel <- detcovar %>% dplyr::select(ModelSite, MeanWind, MeanTime, MeanClouds, "MeanClouds:MeanTemp")
plot_residuals.residual(resid_det, detcovar %>% dplyr::select(ModelSite, MeanClouds)) + 
  coord_cartesian(ylim = c(-0.5, 0.5)) + scale_y_continuous(name = "Detection Residual") 
plot_residuals.residual(resid_det, detcovar %>% dplyr::select(ModelSite, MeanWind)) + 
  coord_cartesian(ylim = c(-0.5, 0.5)) + scale_y_continuous(name = "Detection Residual")
```

Detection residuals for MeanClouds do not suggest adding it to the model. Similarly for MeanWind.

```{r windtemp_time_rarebirds_vcovar, fig.height=12, fig.width=30}
ndetection_species <- colSums(inputdata$plotsmerged_detection[, inputdata$detection_data_specieslist])
rarespecies <- names(ndetection_species)[ndetection_species <= 100]
residrange <- range(resid_det[, rarespecies], na.rm = TRUE)
# detcovar_sel <- detcovar %>% dplyr::select(ModelSite, MeanWind, MeanTime, MeanClouds, "MeanClouds:MeanTemp")
plot_residuals.residual(resid_det[, c("ModelSite", rarespecies)],
                        detcovar %>% dplyr::select(ModelSite, MeanClouds, MeanWind, MeanTime, MeanTemp)) +
  coord_cartesian(ylim = residrange) +
  scale_y_continuous(name = "Detection Residual") 
```

The rare species appear to do ok, visually, for all covariates.

### Quick check of residuals for other models
Note that there are too many data points to apply the shapiro-Wilks normality test directly. A sample of 5000 might be ok though.

```{r all_resid_det_normality}
resid_det_l <- lapply(fittedmods, ds_detection_residuals.fit, type = "median", seed = 321)
vapply(resid_det_l, function(x) shapiro.test(sample(unlist(x[, -1]), 5000))$p.value, FUN.VALUE = 3.3)
```

All detection residuals are close to a normal distribution.

```{r all_resid_occ_normality}
resid_occ_l <- lapply(fittedmods[names(fittedmods) != "interactions_2nd_nolv"], ds_occupancy_residuals.fit, type = "median", seed = 123)
vapply(resid_occ_l, function(x) shapiro.test(sample(unlist(x[, -1]), 5000))$p.value, FUN.VALUE = 3.3)
```

All occupancy residuals appear roughly normal too.

#### Plots against covariates:
```{r residdet_plots_manymodels}
resid_det_df <- bind_rows(resid_det_l[c("windtemp", "windtemp_time", "clouds_time_temp_wind", "timetemp", "clouds", "temp")], .id = "Model")

plt <- resid_det_df %>%
  pivot_longer(-c(ModelSite, Model),
                 names_to = "Species",
                 values_to = "Residual",
                 values_drop_na = TRUE) %>%
  left_join(detcovar %>% 
              dplyr::select(ModelSite, MeanWind, MeanTime, MeanTemp, MeanClouds) %>%
              pivot_longer(-ModelSite,
                 names_to = "Covariate",
                 values_to = "CovariateValue"),
            by = "ModelSite") %>%
  ggplot() +
  ggplot2::facet_grid(rows = vars(Model), cols = vars(Covariate), as.table = TRUE, scales = "free_x") +
  ggplot2::geom_point(aes(x = CovariateValue, y = Residual)) +
  ggplot2::geom_hline(yintercept = 0, col = "blue", lty = "dashed") +
  ggplot2::geom_smooth(aes(x = CovariateValue, y = Residual), method = "gam", level = 0.95, formula = y ~ s(x, bs = "cs")) +
  ggplot2::scale_x_continuous(name = "Covariate Value")
plt + coord_cartesian(ylim = c(-0.1, 0.1))
```

The differences between models are small. Models with Time have accounted for time well, models without Time do not appear to.
But this may not be robust to the randomness of DS residuals.

All model residuals are unrelated to clouds and temperature, even when clouds are not a covariate.

```{r residdet_plots_manymodels_2}
resid_det_l <- lapply(fittedmods, ds_detection_residuals.fit, type = "median")
resid_det_df <- bind_rows(resid_det_l[c("windtemp", "windtemp_time", "clouds_time_temp_wind", "timetemp", "clouds", "temp")], .id = "Model")

plt <- resid_det_df %>%
  pivot_longer(-c(ModelSite, Model),
                 names_to = "Species",
                 values_to = "Residual",
                 values_drop_na = TRUE) %>%
  left_join(detcovar %>% 
              dplyr::select(ModelSite, MeanWind, MeanTime, MeanTemp, MeanClouds) %>%
              pivot_longer(-ModelSite,
                 names_to = "Covariate",
                 values_to = "CovariateValue"),
            by = "ModelSite") %>%
  ggplot() +
  ggplot2::facet_grid(rows = vars(Model), cols = vars(Covariate), as.table = TRUE, scales = "free_x") +
  ggplot2::geom_point(aes(x = CovariateValue, y = Residual)) +
  ggplot2::geom_hline(yintercept = 0, col = "blue", lty = "dashed") +
  ggplot2::geom_smooth(aes(x = CovariateValue, y = Residual), method = "gam", level = 0.95, formula = y ~ s(x, bs = "cs")) +
  ggplot2::scale_x_continuous(name = "Covariate Value")
plt + coord_cartesian(ylim = c(-0.1, 0.1))
```

### Quick Comparison of median LV Values
```{r LVvalues_for_many_models}
LVs <- lapply(fittedmods[c("windtemp", "windtemp_time", "clouds_time_temp_wind", "timetemp", "clouds", "temp")],
              function(x){
                x$data <- as_list_format(x$data)
                theta <- get_theta(x, type = "median")
                LVs <- bugsvar2matrix(theta, "LV", 1:x$data$J, 1:x$data$nlv)
                colnames(LVs) <- c("LV1", "LV2")
                LVs <- as.data.frame(cbind(ModelSite = 1:x$data$J, LVs))
                return(LVs)
              })
LVsdf <- bind_rows(LVs, .id = "Model") %>%
  pivot_longer(cols = c(LV1, LV2), names_to = "LVname", values_to = "LVvalue")

LVsdf_covar <- LVsdf %>%
  left_join(detcovar %>% 
              dplyr::select(ModelSite, MeanWind, MeanTime, MeanTemp, MeanClouds) %>%
              pivot_longer(-ModelSite,
                 names_to = "Covariate",
                 values_to = "CovariateValue"),
            by = "ModelSite")

LVsdf_covar %>%
  group_by(Model, LVname) %>%
  summarise(max_value = max(LVvalue)) #the maximums are different --> LVs are different for each model

LVsdf_covar %>%
  dplyr::filter(LVname == "LV1") %>%
  ggplot() +
      ggplot2::geom_point(aes_(y = ~`LVvalue`, x = ~`CovariateValue`)) +
      ggplot2::facet_grid(cols = vars(`Covariate`), scales = "free") +
      ggplot2::geom_hline(yintercept = 0, col = "blue", lty = "dashed") +
      ggplot2::geom_smooth(aes_(y = ~`LVvalue`, x = ~`CovariateValue`, col = ~`Model`), method = "gam", level = 0.95, formula = y ~ s(x, bs = "cs")) +
  scale_y_continuous(name = "LV1 Value") +
  coord_cartesian(ylim = c(-0.5, 0.5))

LVsdf_covar %>%
  dplyr::filter(LVname == "LV2") %>%
  ggplot() +
      ggplot2::geom_point(aes_(y = ~`LVvalue`, x = ~`CovariateValue`)) +
      ggplot2::facet_grid(cols = vars(`Covariate`), scales = "free") +
      ggplot2::geom_hline(yintercept = 0, col = "blue", lty = "dashed") +
      ggplot2::geom_smooth(aes_(y = ~`LVvalue`, x = ~`CovariateValue`, col = ~`Model`), method = "gam", level = 0.95, formula = y ~ s(x, bs = "cs"), alpha = 0.3) +
  scale_y_continuous(name = "LV2 Value") +
  coord_cartesian(ylim = c(-0.5, 0.5))
```

The median LV value are related to covariates in nearly identical fashion for each model.
For LV1: MeanTemp is roughly constant; MeanClouds is increasing quadratically (or exponentially); MeanTime is linear; MeanWind is sinusoidal.
For LV2: MeanTime is constant; MeanClouds, MeanTemp relations look similar to each other and are complicated.

## Holdout lppd
#### Log Posterior Density
```{r holdoutlpd}
lpds_l <- readRDS("./tmpdata/7_2_2_lppds.rds")
names(lpds_l)[10] <- "clouds_time_temp_wind" 
lpds_df <- as_tibble(do.call(cbind, lapply(lpds_l, function(x) x$lpds)))
melpd <- data.frame(Estimate = apply(lpds_df, 2, mean),
                    SE = apply(lpds_df, 2, sd) / sqrt(nrow(lpds_df)))

lpds_df %>%
  as_tibble() %>%
  rowid_to_column(var = "HoldOutModelSite") %>%
  tidyr::pivot_longer(-HoldOutModelSite, names_to = "model", values_to = "Site_lpd") %>%
  ggplot() +
  facet_grid(rows = vars(model), scales = "free_y") +
  geom_violin(aes(x = Site_lpd, y = model)) +
  stat_summary(aes(x = Site_lpd, y = model),
               fun = mean, geom = "point", shape = 23, size = 2) +
  stat_summary(aes(x = Site_lpd, y = model),
               fun = function(x) mean(x) - 2*sd(x)/sqrt(nrow(lpds_df)), geom = "crossbar") +
  stat_summary(aes(x = Site_lpd, y = model),
               fun = function(x) mean(x) + 2*sd(x)/sqrt(nrow(lpds_df)), geom = "crossbar")
```

Of the fitted objects that appeared to have good MCMC chains, the best lppd is the windtemp_time model. However the distribution of mean lpd for a ModelSite is very similar for each model, suggesting that the lppds are not a good indication of a good detection model.

```{r distributioninsampleoutsamplelpd, fig.height=10}
waics_l <- readRDS("./tmpdata/7_2_2_waics.rds")
insamplelpds_df <- do.call(cbind, lapply(waics_l, function(x) x$waic$pointwise[, "elpd_waic"])) %>%
  as_tibble() %>% mutate(InSample = TRUE)

df <- lpds_df %>% as_tibble() %>% mutate(InSample = FALSE)

df <- bind_rows(insamplelpds_df, df)

df %>%
  as_tibble() %>%
  tidyr::pivot_longer(-InSample, names_to = "model", values_to = "site_lpd") %>%
  ggplot() +
  facet_grid(rows = vars(model, InSample), scales = "free_y") +
  geom_violin(aes(x = site_lpd, y = model, col = InSample)) +
  stat_summary(aes(x = site_lpd, y = model),
               fun = mean, geom = "point", shape = 23, size = 2) +
  stat_summary(aes(x = site_lpd, y = model),
               fun = function(x) mean(x) - 2*sd(x)/sqrt(nrow(lpds_df)), geom = "crossbar") +
  stat_summary(aes(x = site_lpd, y = model),
               fun = function(x) mean(x) + 2*sd(x)/sqrt(nrow(lpds_df)), geom = "crossbar")
```

The differences between in-sample and out-of-sample lpd values appears to most be due to tails in the distribution. An exception is the InSample windtimetemp_clouds data, which appears to have a wider lower tail also.

### vs WAIC
```{r waics}
waics_l <- readRDS("./tmpdata/7_2_2_waics.rds")
waics_average_elpd_per_point <- lapply(waics_l, function(x) x$waic$estimates["elpd_waic", ]/nrow(x$waic$pointwise))
waics_average_elpd_per_point <- simplify2array(waics_average_elpd_per_point)
waics_average_elpd_per_point <- t(waics_average_elpd_per_point) %>% as_tibble(rownames = "Model")
waics_average_elpd_per_point$type = "WAIC"

loo_average_elpd_per_point <- lapply(waics_l, function(x) x$loo$estimates["elpd_loo", ]/nrow(x$waic$pointwise))
loo_average_elpd_per_point <- simplify2array(loo_average_elpd_per_point)
loo_average_elpd_per_point <- t(loo_average_elpd_per_point) %>% as_tibble(rownames = "Model")
loo_average_elpd_per_point$type = "LOO-PSIS"

melpd$type <- "Holdout"
melpd <- as_tibble(melpd, rownames = "Model")

df <- bind_rows(waics_average_elpd_per_point, loo_average_elpd_per_point, melpd)

df %>%
  ggplot() +
  geom_errorbar(aes(x = Model, ymax = Estimate +  2*SE, ymin = Estimate - 2*SE, col = type, lty = type)) +
  geom_point(aes(x = Model, y = Estimate, col = type), position = position_jitter(width = 0.1)) +
  coord_flip()
```

The WAIC estimates show much greater variety than the holdout estimates of mean site log posterior density.
The WAIC estimates suggest windtemp, wind, temp or clouds as the best models. NOT windtemp_time or clouds_time_temp_wind.
However, this difference is all due to the bias correction of using insample data. The plot below shows that the site lpd of insample and out-of-sample data is very similar in distribution.
In looks like the variety in WAIC estimates is due to extremely low likelihoods for some insample data.

Despite the difference in WAIC estimates, the actual performance of the models is very similar.

## Average LV Loadings
Will only consider: clouds, clouds_time_temp_wind, temp, wind, windtemp_time.

```{r averageLVloadings}
# median across species, for a particular parameter draw
medianLVloadsize <- function(fit, type = "median"){
  fit$data <- as_list_format(fit$data)
  theta <- get_theta(fit, type = "median")
  LVload <- bugsvar2matrix(theta, "lv.coef", 1:fit$data$n, 1:fit$data$nlv)
  speciesmedian_loadsize <- median(sqrt(rowSums(LVload^2)))
  return(speciesmedian_loadsize)
}
medianLVloadsizes <- vapply(fittedmods[c("clouds", "clouds_time_temp_wind", "temp", "wind", "windtemp_time")],
                            medianLVloadsize, FUN.VALUE = 3.3)
medianLVloadsizes
```

The load sizes are nearly identical, suggesting that the covariates in each model explain a similar amount of the observed detections.

```{r averageLVvalues}
# median across species, for a particular parameter draw
medianLVsize <- function(fit){
  fit$data <- as_list_format(fit$data)
  theta <- get_theta(fit, type = "median")
  LVs <- bugsvar2matrix(theta, "LV", 1:fit$data$J, 1:fit$data$nlv)
  speciesmedian_size <- median(sqrt(rowSums(LVs^2)))
  return(speciesmedian_size)
}
medianLVsizes <- vapply(fittedmods[c("clouds", "clouds_time_temp_wind", "temp", "wind", "windtemp_time")],
                            medianLVsize, FUN.VALUE = 3.3)
medianLVsizes
```

As anticipated, LV are about the same magnitude for every model.

## Covariate Loadings
```{r covariateloadings}
v.b_median <- function(fit) {
  fit$data <- as_list_format(fit$data)
  theta <- get_theta(fit, type = "median")
  v.b <- bugsvar2matrix(theta, "v.b", 1:fit$data$n, 1:fit$data$Vobs)
  colnames(v.b) <- names(fit$XobsProcess$center)
  rownames(v.b) <- fit$species
  v.b <- as_tibble(v.b, rownames = "Species")
  return(v.b)
}
v.b_l <- lapply(fittedmods, v.b_median)
v.b_longer <- lapply(v.b_l,
                     function(x) pivot_longer(x, -Species, names_to = "Covariate", values_to = "CovariateValue"))
df <- bind_rows(v.b_longer, .id = "Model")

df %>%
  ggplot() +
  facet_wrap(vars(Species), nrow = 4) +
  geom_point(aes(y = Covariate, x = CovariateValue,
                 col = Model,
                 shape = Model)) +
  scale_color_viridis_d() +
  scale_shape_manual(values = rep(0:5, 3))

df %>%
  ggplot() +
  facet_wrap(vars(Covariate), nrow = 1) +
  geom_point(aes(y = Species, x = CovariateValue,
                 col = Model,
                 shape = Model)) +
  scale_color_viridis_d() +
  scale_shape_manual(values = rep(0:5, 3))
```

It is very hard to compare covariate loadings between models, as the covariates are different.
The intercept loading and the MeanTime loading both appear to be substantial, whilst other covariates appear to have close to zero loading.

There are differences between models, but these may be due to lack of convergence.

## Conclusions
### Questions
+ What does it mean to investigate the occupancy residual of a detection covariate? If there is an effect it means that the detection covariate is correlated to occupancy, perhaps through climate, or geographic location.
+ Include MeanWind^2?
+ Include MeanTime^2? *this could be checked by plotting residuals against MeanTime*
+ A model of MeanWind^2 + MeanTime^2 + MeanClouds^2 + MeanTemp^2 could work?
+ Models that include interactions MeanClouds:MeanTemp, MeanTime:MeanTemp, MeanTime:MeanWind, MeanTime:MeanClouds (MeanWind:MeanTemp alread in model) could mean MeanTime^2 etc isn't needed.

### Future Models
For future detections try: 
~ MeanWind * MeanTemp + MeanTime + MeanClouds * MeanTemp + MeanTime * MeanTemp + MeanTime * MeanWind + MeanTime * MeanClouds

This has (4 + 5 + 1 = 10) covariates.


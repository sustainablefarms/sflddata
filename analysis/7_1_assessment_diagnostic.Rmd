---
title: "Diagnostic and Assesment of 7_1 model"
author: "Kassel Hingee"
date: "25/03/2020"
output: 
  html_document: 
    toc: yes
---

```{r setup, include=FALSE}
library(tibble)
library(dplyr)
library(MCMCpack)
library(mclust)
library(corrplot)
library(coda)
library(runjags)
```

```{r importdata, echo = FALSE, include = FALSE}
# setwd("..")
source("./scripts/7_1_import_site_observations.R")
```
```{r importmodelfit, out.width=14}
fit <- readRDS("./tmpdata/7_1_mcmcchain_20200420.rds")
fit <- add.summary(fit)
print(fit)
```

lv.coef[1,2] did have a stochastic nature because constraint on lv.coef are such that the upper diagonal (i.e. lv.coef[1, 2]) is always 0.

## Diagnostics of MCMC Chain Convergence
### Gelman-Rubin Statistic or "Rhat"
I think values less than 1.1 are desired.
Using this it appears that u.b[3,1] and many lv.coef components did not converge.
Some lv.coef components have __very__ high Rhat.

```{r gelmanrubin}
sm <- as_tibble(summary(fit), rownames = "varname")
sm %>%
  dplyr::filter(psrf >= 1.1) %>%
  dplyr::select(varname) %>%
  as.list()
```


### Traces
```{r newchaingdiagnostics1}
plot(fit, plot.type = "trace", vars = grep("lv.coef\\[.*,1\\]", sm$varname, value = TRUE),
     layout = c(2, 5))
plot(fit, plot.type = "trace", vars = grep("lv.coef\\[([2-9]|[1-9].).*,2\\]", sm$varname, value = TRUE),
     layout = c(2, 5))
plot(fit, plot.type = "trace", vars = sm$varname[[1]], separate.chains = TRUE, layout = c(5, 1))
plot(fit, plot.type = "trace", vars = grep("u.b\\[.*,1\\]", sm$varname, value = TRUE),
     layout = c(3, 5))
```

#### Observations
+ lv.coef chains differ wildly depending on the initial conditions.
Some of this could be explained by the unidentifiability of the latent variables (the Boral help says that this is the main reason why only one chain is run in Boral)
  + lv.coef[.*,2] values appear to have similar magnitude by the end of 70000 iterations. Consistent with the unidentifiability of the sign issue.
  + the behaviour of the lv.coef[.*,1] is not explained by the sign unidentifiability. The chains appear to get closer in magnitude and sign by 70000 iterations, but are not perfectly matching.
  + I think prior restrictions on LV and lv.coefs by Tobler removed this unidentifiability - at least Tobler runs 3 chains without any trouble!
  + Slower LV convergence is something that Tobler experienced I think.
+ u.b samples appear ok except u.b[3,1] which looks like it didn't converge until iteration 40000.
  + Note that u.b[3,1] corresponds to the interpect for the Australian Raven. Perhaps there is not enough data for it, or it is too likely to be present?
+ Chains 1, 3, 5 appear to be identical suggesting the initial conditions of these were identical.
  + Similary for chains 2 and 4.
  + However there should be 4 different sets of initial conditions.


### Further Analysis with help from ggmcmc
* Densities from each chain
* Rhat
* Geweke
* Autocorrelation
* Cross-Correlation __unfinished__

```{r ggmcmc_prep}
library(ggmcmc)
fit.ggs <- ggs(coda::as.mcmc.list(fit), sort = TRUE)  #z is too large to include here (causes R to crash)
```

#### Densities
```{r densities, fig.width = 12, fig.height = 10}
ggs_density(fit.ggs, family = "lv.coef\\[.*,1\\]") + facet_wrap(~ Parameter) + ggtitle("1st LV")
ggs_density(fit.ggs, family = "lv.coef\\[.*,2\\]") + facet_wrap(~ Parameter) + ggtitle("2nd LV")
ggs_density(fit.ggs, family = "(lv.coef\\[1,1\\]|lv.coef\\[2,2\\])") + facet_wrap(~ Parameter) + ggtitle("Sign-fixing LV Coefficients")
ggs_density(fit.ggs, family = "^mu.u.b") + facet_wrap(~ Parameter, scales = "free")
ggs_density(fit.ggs, family = "^mu.v.b") + facet_wrap(~ Parameter, scales = "free")
ggs_density(fit.ggs, family = "^u.b") + facet_wrap(~ Parameter, scales = "free")
ggs_density(fit.ggs, family = "^v.b") + facet_wrap(~ Parameter, scales = "free")
```

There is something funky happening with the chains.
There should be 4 different chains, but so many of them are duplicated that there only appears to be 2 different chains. How is this possible?

The sign of LV2 flipping between chains could be because it appears that the Australian Magpie (species 2) is quite independent of other species.

The following checks this using correlation of the raw observations:
```{r correlationbetweenspecies}
interspeciescor <- detection_data %>%
  dplyr::select(all_of(detection_data_specieslist)) %>%
  cor()

as_tibble(interspeciescor, rownames = "species") %>%
  pivot_longer(-species) %>%
  filter(species != name) %>%
  ggplot() +
  facet_wrap(~name) +
  geom_vline(xintercept = c(-0.2, 0.2), col = "grey", lty = "dashed") +
  geom_point(aes(x = value, y = species))


reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <- cormat[hc$order, hc$order]
}


interspeciescor %>%
  reorder_cormat() %>%
  reshape2::melt(value.name = "Pearson Correlation") %>%
  ggplot() +
  geom_tile(aes(x = Var1, y = Var2, fill = `Pearson Correlation`)) +
  # scale_fill_viridis_c(limits = c(-0.4, 0.4)) +
  scale_fill_gradient2(limits = c(-0.4, 0.4), low = scales::muted("red"), mid = "white", high = scales::muted("green")) +
  # scale_shape_manual(name = "Correlation < 0.9", values = c(NA, 19)) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  ggtitle("Pearson Correlation between Detections of Species")
```

Australia Magpie and the Austalasian Pipit detections had low correlation (absolute correlation less than 0.2) with all other species. Many species in this data set are like this.

There are two clusters of species with higher correlation (about 0.4).
One is around the Superb Fairy Wren, and another is around the Willie Wagtail.


#### Geweke
I am not sure how to use this. I think 95% of dots should be within -2 and 2?
I suspect the main information of the plot will be similar to the information from Rhat and the trace plots.

```{r geweke}
ggs_geweke(fit.ggs, family = "^[v].*") 
ggs_geweke(fit.ggs, family = "^[mt].*") 
ggs_geweke(fit.ggs, family = "^l.*\\]$")
```

#### Autocorrelation

The runjags summary function has computed autocorrelation up to 500 iterations (equal to 10 samples). We'd like it if the autocorrelation was close 0. Auto-correlation of most parameters less than 0.1. Some are greater than 0.1 though

```{r autocorr_fromsummary}
hist(sm$AC.500)
sm %>% 
  filter(AC.500 >= 0.1) %>% 
  dplyr::select(varname, AC.500) %>%
  deframe()
```

Lots of autocorrelation: occassional covariate coefficients for species and many of the latent variables.
This is better than first run in March, in that fit many of the u.b and v.b components had autocorrelation.

The species that had high autocorrelation were `r detection_data_specieslist[c(3, 26, 43)]`: "Australian Raven", "Laughing Kookaburra" "Stubble Quail".

The lv.coef can have very large autocorrelation so we don't look them below. Autocorrelation plots of u.b[, 1] components don't show much interesting structure and confirm the above numerical summaries.
The mu and tau components have little autocorrelation.

```{r autocorrelation}
ggs_autocorrelation(fit.ggs, family = "^[u].*\\[.*,1\\]") +
  facet_wrap(~ Parameter) +
  aes(fill = NULL, alpha = 0)
ggs_autocorrelation(fit.ggs, family = "^[mt].*") +
  facet_wrap(~ Parameter) +
  aes(fill = NULL, alpha = 0)
```

#### Cross-Correlation (NOT PERFORMED)
```{r crosscorrelation}
ggs_crosscorrelation(fit.ggs)
# ggs_pairs(fit.ggs, lower = list(continuous = "density"))
```



### Correlation Between Variables (NOT PERFORMED)

### Compare to chains with very different initial conditions (NOT PERFORMED)

### Other Diagnostics of Whether Model has Updated Successfully?  (NOT PERFORMED)
```{r ggmcmc1, eval = FALSE}

ggs_compare_partial(fit.ggs, family = "lv.coef\\[.,1\\]")
ggs_compare_partial(fit.ggs, family = "lv.coef\\[.,2\\]")
ggs_crosscorrelation(fit.ggs)
ggs_pairs(fit.ggs, lower = list(continuous = "density"))

ggs_rocplot(fit.ggs, outcome = "y")

ggs_autocorrelation(fit.ggs, family = "lv.coef\\[.,1\\]") +
  facet_wrap(~ Parameter) +
  aes(fill = NULL, alpha = 0)
```

## Assess Model
The latent variable information is totally untrustworthy. I don't have the latent variables anyway.

The occupancy probability of site should be possible to compute, and the dependence on covariates.

### Caterpilla Plots of Covariates
```{r caterpillar_occupancy, fig.height = 12}
speciesnameWparamname <- function(shortparamname, speciesnames, colidx){
  setNames(speciesnames, paste0(shortparamname,"[",1:length(speciesnames),",",colidx,"]"))
}
ggs_caterpillar(fit.ggs, family = "u.b\\[.*,1\\]") +
  ggtitle("Intercept Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("u.b", detection_data_specieslist, 1))
ggs_caterpillar(fit.ggs, family = "u.b\\[.*,2\\]") +
  ggtitle("os_cover Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("u.b", detection_data_specieslist, 2))
ggs_caterpillar(fit.ggs, family = "u.b\\[.*,3\\]") +
  ggtitle("log(ms_cover + 1) Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("u.b", detection_data_specieslist, 3))
ggs_caterpillar(fit.ggs, family = "u.b\\[.*,4\\]") +
  ggtitle("NMDetected Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("u.b", detection_data_specieslist, 4))
```

Note in the above: thick line is 0.05 to 0.95 credible interval. Thin line is 0.025 - 0.975 credible interval.
The intercept presumably gives the overall presence of each bird. Magpie is top of the list as I expected.
I'm not sure if the dependence on overstory and midstory makes sense.
I'm guessing large birds (cockatoos) do not like mid story; Sulphur-crested Cockatoo has one of the most negative response to midstorey. Striated Pardalotes, Galah and Starlings all displike midstorey to a similar amount according to this model.


```{r caterpillar_detectionprob, fig.height = 12}
ggs_caterpillar(fit.ggs, family = "v.b\\[.*,1\\]") +
  ggtitle("Intercept Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("v.b", detection_data_specieslist, 1))
ggs_caterpillar(fit.ggs, family = "v.b\\[.*,2\\]") +
  ggtitle("MeanWind Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("v.b", detection_data_specieslist, 2))
ggs_caterpillar(fit.ggs, family = "v.b\\[.*,3\\]") +
  ggtitle("MeanTime Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("v.b", detection_data_specieslist, 3))
```

Not much differences of wind on the different species, though for many detection probability is negatively associated with windiness.
It would seem that the birds differ a little bit in their response to the time of day (Dusky Woodswallow detections correlated to visits later in the morning!). 

The greater impact of windiness is consistent with Wade's findings.
__Knowing a little bit more about the different species' behaviour would allow me to assess the models easier, but perhaps taint my interpretations of the models?__

### Detections vs fitted detection probability
__How to do this?!__

I could plot all visits, ordered by fitted detection probability. On the y-axis plot actual detections as points and fitted probability of detection as a curve. 

```{r fitteddetectionprobabilities}
# detection covariates of wind, survey time, only a constant as occupancy covariate
Xocc <- model.matrix(as.formula("~ os_cover + log(ms_cover + 1) + NMdetected"), data = occ_covariates) #first column is intercept
Xocc[, -1] <- scale(Xocc[, -1])
occ_coefs <- sm %>% 
  filter(grepl("^u.b", varname)) %>%
  dplyr::select(varname, Median) %>%
  mutate(occ_predictor = gsub("\\]$", "", gsub(".*\\[.*,", "", varname))) %>%
  mutate(occ_species = gsub(",.*\\]$", "", gsub(".*\\[", "", varname))) %>%
  dplyr::select(-varname) %>%
  pivot_wider(names_from = occ_predictor, values_from = Median, names_prefix = "OccPred_") %>%
  arrange(occ_species) %>%
  dplyr::select(-occ_species)
# probability of occupancy is the probability that a standard normal RV with mean given by Xocc %*% t(occ_coefs) + Latent Variables is positive. I.e. the probability that a standard normal with mean 0 is greater than - Xocc %*% t(occ_coefs) + Latent Variables.
fitted.occ <- 1 - pnorm(-Xocc %*% t(occ_coefs), mean = 0) #this is the probability of occupancy
dimnames(fitted.occ)[[2]] <- detection_data_specieslist
stopifnot(all.equal(as.integer(dimnames(fitted.occ)[[1]]), occ_covariates$SiteID))
fitted.occ <- as_tibble(fitted.occ, rownames = "SiteID") %>% mutate(SiteID = as.integer(SiteID))

Xobs <- model.matrix(as.formula("~ MeanWind + MeanTime + 1"), data = detection_data)
Xobs[, -1] <- scale(Xobs[, -1])
det_coefs <- sm %>% 
  filter(grepl("^v.b", varname)) %>%
  dplyr::select(varname, Median) %>%
  mutate(predictor = gsub("\\]$", "", gsub(".*\\[.*,", "", varname))) %>%
  mutate(species = gsub(",.*\\]$", "", gsub(".*\\[", "", varname))) %>%
  dplyr::select(-varname) %>%
  pivot_wider(names_from = predictor, values_from = Median, names_prefix = "DetPredictor_") %>%
  arrange(species) %>%
  dplyr::select(-species)
linpred <- Xobs %*% t(det_coefs)
fitted.det <- exp(linpred) / (exp(linpred) + 1)   #this is the inverse logit function
dimnames(fitted.det)[[2]] <- detection_data_specieslist
fitted.det <- as_tibble(fitted.det)
fitted.det$SiteID <- detection_data$SiteID

fitted.obsprob <- (fitted.occ %>%
  right_join(fitted.det %>% dplyr::select("SiteID"), by = "SiteID") %>%
  dplyr::select(-SiteID)) *
  (fitted.det %>% dplyr::select(-SiteID))
```

```{r fittedprob_onaverage, fig.height = 10}
colMeans(fitted.obsprob) %>%
  enframe() %>%
  inner_join(enframe(colMeans(detection_data[, detection_data_specieslist])),
             by = "name", suffix = c(".fit", ".obs")) %>%
  pivot_longer(-name, names_to = "type", values_to = "value") %>%
  ggplot() +
  geom_bar(aes(y = name, x = value, fill = type), stat = "identity", position = "dodge") +
  ggtitle("Mean Fitted Detection Probability Across All Sites") +
  scale_color_viridis_d()
```

On average the fitted probability does very poorly. I thought it would do better considering it could use unique intercept for each species (up to the random effect restriction).
The Australian Magpie is an example. Wow! It is bad!

```{r particularspecies}
specname <- "Weebill"# detection_data_specieslist[[1]]
aspecies <- tibble(obs = detection_data[, specname], 
                   fit = fitted.obsprob[, specname])
aspecies %>%
  arrange(fit) %>%
  rowid_to_column() %>%
  ggplot() +
  geom_point(aes(x = rowid, y = obs), position = "jitter") +
  geom_line(aes(x = rowid, y = fit), col = "blue", lwd = 2) +
  ggtitle(specname)

specname <- "Sacred Kingfisher"# detection_data_specieslist[[1]]
aspecies <- tibble(obs = detection_data[, specname], 
                   fit = fitted.obsprob[, specname])
aspecies %>%
  arrange(fit) %>%
  rowid_to_column() %>%
  ggplot() +
  geom_point(aes(x = rowid, y = obs), position = "jitter") +
  geom_line(aes(x = rowid, y = fit), col = "blue", lwd = 2) +
  ggtitle(specname)
```


Ok so even though the fitted coefficients made sense, the actual predictions are really really poor.

## Improvements
* Look at the fitted probabilities and compare to observations some how.

* Debug issue with initial values replicating.
* Track the LV values outside R using 
* Put a species in each correlation cluster into first - so that LV's are sign-constrained.


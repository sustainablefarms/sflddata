---
title: "Diagnostic and Assesment of 7_1 model"
author: "Kassel Hingee"
date: "26/04/2020"
output: 
  html_document: 
    toc: yes
---

```{r setup, include=FALSE}
library(tibble)
library(dplyr)
library(MCMCpack)
library(mclust)
library(corrplot)
library(coda)
library(runjags)
```

```{r importdata, echo = FALSE, include = FALSE}
# setwd("..")
source("./scripts/7_1_import_site_observations.R")
```
```{r importmodelfit, out.width=14}
fit <- readRDS("./tmpdata/7_1_mcmcchain_20200424.rds")
fit <- add.summary(fit)
print(fit)
```

lv.coef[1,2] did not have a stochastic nature because constraint on lv.coef are such that the upper diagonal (i.e. lv.coef[1, 2]) is always 0.

## Diagnostics of MCMC Chain Convergence
### Gelman-Rubin Statistic or "Rhat"
I think values less than 1.1 are desired.
Using this it appears that all coefficients converged well :).

```{r gelmanrubin}
sm <- as_tibble(summary(fit), rownames = "varname")
sm %>%
  dplyr::filter((psrf >= 1.1) | is.na(psrf)) %>%
  dplyr::select(varname) %>%
  as.list()
```


### Traces
```{r newchaingdiagnostics1}
plot(fit, plot.type = "trace", vars = grep("lv.coef\\[.*,1\\]", sm$varname, value = TRUE),
     layout = c(2, 5))
plot(fit, plot.type = "trace", vars = grep("lv.coef\\[([2-9]|[1-9].).*,2\\]", sm$varname, value = TRUE),
     layout = c(2, 5))
plot(fit, plot.type = "trace", vars = sm$varname[[1]], separate.chains = TRUE, layout = c(5, 1))
plot(fit, plot.type = "trace", vars = grep("u.b\\[.*,1\\]", sm$varname, value = TRUE),
     layout = c(3, 5))
```

#### Observations
+ lv.coef chains appear to be similar in all chains, though not identical. It seems that longer burn-in and choosing the first few species (for which the LV sign depends) to represent species that have correlations in the detections has worked.
+ u.b samples appear ok except u.b[26,1] and u.b[28,1] have spikes in one of their chains.



### Further Analysis with help from ggmcmc
* Densities from each chain
* Rhat
* Geweke
* Autocorrelation
* Cross-Correlation __unfinished__

```{r ggmcmc_prep}
library(ggmcmc)
fit.ggs <- ggs(coda::as.mcmc.list(fit), sort = TRUE)  #z is too large to include here (causes R to crash)
```

#### Densities
```{r densities, fig.width = 12, fig.height = 10}
ggs_density(fit.ggs, family = "lv.coef\\[.*,1\\]") + facet_wrap(~ Parameter) + ggtitle("1st LV")
ggs_density(fit.ggs, family = "lv.coef\\[.*,2\\]") + facet_wrap(~ Parameter) + ggtitle("2nd LV")
ggs_density(fit.ggs, family = "(lv.coef\\[1,1\\]|lv.coef\\[2,2\\])") + facet_wrap(~ Parameter) + ggtitle("Sign-fixing LV Coefficients")
ggs_density(fit.ggs, family = "^mu.u.b") + facet_wrap(~ Parameter, scales = "free")
ggs_density(fit.ggs, family = "^mu.v.b") + facet_wrap(~ Parameter, scales = "free")
ggs_density(fit.ggs, family = "^u.b") + facet_wrap(~ Parameter, scales = "free")
ggs_density(fit.ggs, family = "^v.b") + facet_wrap(~ Parameter, scales = "free")
```

There are some differences between densities from each chain for the 1st LV.
I'm not happy about that.
The differences are a bit smaller for the 2nd LV and other monitored parameters.

There are two clusters of species with higher correlation (about 0.4).
One is around the Superb Fairy Wren, and another is around the Willie Wagtail.
These have been used to fix the sign of latent variables.
The correlations between detections of species are shown below.
Australia Magpie and the Austalasian Pipit detections had low correlation (absolute correlation less than 0.2) with all other species. Many species in this data set are like this.
```{r correlationbetweenspecies, fig.height = 12, fig.width = 12}
interspeciescor <- detection_data %>%
  dplyr::select(all_of(detection_data_specieslist)) %>%
  cor()

as_tibble(interspeciescor, rownames = "species") %>%
  pivot_longer(-species) %>%
  filter(species != name) %>%
  ggplot() +
  facet_wrap(~name) +
  geom_vline(xintercept = c(-0.2, 0.2), col = "grey", lty = "dashed") +
  geom_point(aes(x = value, y = species))


reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <- cormat[hc$order, hc$order]
}


interspeciescor %>%
  reorder_cormat() %>%
  reshape2::melt(value.name = "Pearson Correlation") %>%
  ggplot() +
  geom_tile(aes(x = Var1, y = Var2, fill = `Pearson Correlation`)) +
  # scale_fill_viridis_c(limits = c(-0.4, 0.4)) +
  scale_fill_gradient2(limits = c(-0.4, 0.4), low = scales::muted("red"), mid = "white", high = scales::muted("green")) +
  # scale_shape_manual(name = "Correlation < 0.9", values = c(NA, 19)) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
  ggtitle("Pearson Correlation between Detections of Species")
```


#### Geweke
I am not sure how to use this. I think 95% of dots should be within -2 and 2?
I suspect the main information of the plot will be similar to the information from Rhat and the trace plots.

```{r geweke}
ggs_geweke(fit.ggs, family = "^[v].*") + scale_colour_viridis_d(option = "inferno")
ggs_geweke(fit.ggs, family = "^[mt].*") + scale_colour_viridis_d(option = "inferno")
ggs_geweke(fit.ggs, family = "^l.*\\]$") + scale_colour_viridis_d(option = "inferno")
```

Geweke numbers suggest a few too many coefficients/chains did not behave perfectly: more that 5% appear to be outside the -2 to 2 range.
Looks like chain 3 for the latent variables is particular guilty of these points.

#### Autocorrelation

The runjags summary function has computed autocorrelation up to 100 iterations (equal to 10 samples). We'd like it if the autocorrelation was close 0. Auto-correlation of most parameters less than 0.1. Some are greater than 0.1 though, and these a spread between u.b, v.b, and lv.coef values.

```{r autocorr_fromsummary}
hist(sm$AC.100)
sm %>% 
  filter(AC.100 >= 0.1) %>% 
  dplyr::select(varname, AC.100) %>%
  deframe()
```

Autocorrelation plots of u.b[, 1] components are consistent with a number of variables showing correlation across a large number of updates.
The mu and tau components have little autocorrelation.

```{r autocorrelation}
ggs_autocorrelation(fit.ggs, family = "^[u].*\\[.*,1\\]") +
  facet_wrap(~ Parameter) +
  aes(fill = NULL, alpha = 0)
ggs_autocorrelation(fit.ggs, family = "^[mt].*") +
  facet_wrap(~ Parameter) +
  aes(fill = NULL, alpha = 0)
```

#### Cross-Correlation (NOT PERFORMED)
```{r crosscorrelation}
ggs_crosscorrelation(fit.ggs)
# ggs_pairs(fit.ggs, lower = list(continuous = "density"))
```



### Correlation Between Variables (NOT PERFORMED)

### Compare to chains with very different initial conditions (NOT PERFORMED)

### Other Diagnostics of Whether Model has Updated Successfully?  (NOT PERFORMED)
```{r ggmcmc1, eval = FALSE}

ggs_compare_partial(fit.ggs, family = "lv.coef\\[.,1\\]")
ggs_compare_partial(fit.ggs, family = "lv.coef\\[.,2\\]")
ggs_crosscorrelation(fit.ggs)
ggs_pairs(fit.ggs, lower = list(continuous = "density"))

ggs_rocplot(fit.ggs, outcome = "y")

ggs_autocorrelation(fit.ggs, family = "lv.coef\\[.,1\\]") +
  facet_wrap(~ Parameter) +
  aes(fill = NULL, alpha = 0)
```

## Assess Model
The latent variable information is totally untrustworthy. I don't have the latent variables anyway.

The occupancy probability of site should be possible to compute, and the dependence on covariates.

### Caterpilla Plots of Covariates
```{r caterpillar_occupancy, fig.height = 12}
speciesnameWparamname <- function(shortparamname, speciesnames, colidx){
  setNames(speciesnames, paste0(shortparamname,"[",1:length(speciesnames),",",colidx,"]"))
}
ggs_caterpillar(fit.ggs, family = "u.b\\[.*,1\\]") +
  ggtitle("Intercept Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("u.b", detection_data_specieslist, 1))
ggs_caterpillar(fit.ggs, family = "u.b\\[.*,2\\]") +
  ggtitle("os_cover Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("u.b", detection_data_specieslist, 2))
ggs_caterpillar(fit.ggs, family = "u.b\\[.*,3\\]") +
  ggtitle("log(ms_cover + 1) Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("u.b", detection_data_specieslist, 3))
ggs_caterpillar(fit.ggs, family = "u.b\\[.*,4\\]") +
  ggtitle("NMDetected Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("u.b", detection_data_specieslist, 4))
```

Note in the above: thick line is 0.05 to 0.95 credible interval. Thin line is 0.025 - 0.975 credible interval.
The intercept presumably gives the overall presence of each bird. Magpie is top of the list as I expected.
I'm not sure if the dependence on overstory and midstory makes sense.
I'm guessing large birds (cockatoos) do not like mid story; Sulphur-crested Cockatoo has one of the most negative response to midstorey. Striated Pardalotes, Galah and Starlings all displike midstorey to a similar amount according to this model.


```{r caterpillar_detectionprob, fig.height = 12}
ggs_caterpillar(fit.ggs, family = "v.b\\[.*,1\\]") +
  ggtitle("Intercept Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("v.b", detection_data_specieslist, 1))
ggs_caterpillar(fit.ggs, family = "v.b\\[.*,2\\]") +
  ggtitle("MeanWind Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("v.b", detection_data_specieslist, 2))
ggs_caterpillar(fit.ggs, family = "v.b\\[.*,3\\]") +
  ggtitle("MeanTime Coefficient") +
  scale_y_discrete(labels = speciesnameWparamname("v.b", detection_data_specieslist, 3))
```

Not much differences of wind on the different species, though for many detection probability is negatively associated with windiness.
It would seem that the birds differ a little bit in their response to the time of day (Dusky Woodswallow detections correlated to visits later in the morning!). 

The greater impact of windiness is consistent with Wade's findings.
__Knowing a little bit more about the different species' behaviour would allow me to assess the models easier, but perhaps taint my interpretations of the models?__

### Detections vs fitted detection probability
I could plot all visits, ordered by fitted detection probability. On the y-axis plot actual detections as points and fitted probability of detection as a curve. 

```{r fitteddetectionprobabilities}
# detection covariates of wind, survey time, only a constant as occupancy covariate
Xocc <- model.matrix(as.formula("~ os_cover + log(ms_cover + 1) + NMdetected"), data = occ_covariates) #first column is intercept
Xocc[, -1] <- scale(Xocc[, -1])
occ_coefs <- sm %>% 
  filter(grepl("^u.b", varname)) %>%
  dplyr::select(varname, Median) %>%
  mutate(occ_predictor = gsub("\\]$", "", gsub(".*\\[.*,", "", varname))) %>%
  mutate(occ_species = gsub(",.*\\]$", "", gsub(".*\\[", "", varname))) %>%
  dplyr::select(-varname) %>%
  pivot_wider(names_from = occ_predictor, values_from = Median, names_prefix = "OccPred_") %>%
  arrange(occ_species) %>%
  dplyr::select(-occ_species)
# probability of occupancy is the probability that a standard normal RV with mean given by Xocc %*% t(occ_coefs) + Latent Variables is positive. I.e. the probability that a standard normal with mean 0 is greater than - Xocc %*% t(occ_coefs) + Latent Variables.
fitted.occ <- 1 - pnorm(-Xocc %*% t(occ_coefs), mean = 0) #this is the probability of occupancy
dimnames(fitted.occ)[[2]] <- detection_data_specieslist
stopifnot(all.equal(as.integer(dimnames(fitted.occ)[[1]]), occ_covariates$SiteID))
fitted.occ <- as_tibble(fitted.occ, rownames = "SiteID") %>% mutate(SiteID = as.integer(SiteID))

Xobs <- model.matrix(as.formula("~ MeanWind + MeanTime + 1"), data = detection_data)
Xobs[, -1] <- scale(Xobs[, -1])
det_coefs <- sm %>% 
  filter(grepl("^v.b", varname)) %>%
  dplyr::select(varname, Median) %>%
  mutate(predictor = gsub("\\]$", "", gsub(".*\\[.*,", "", varname))) %>%
  mutate(species = gsub(",.*\\]$", "", gsub(".*\\[", "", varname))) %>%
  dplyr::select(-varname) %>%
  pivot_wider(names_from = predictor, values_from = Median, names_prefix = "DetPredictor_") %>%
  arrange(species) %>%
  dplyr::select(-species)
linpred <- Xobs %*% t(det_coefs)
fitted.det <- exp(linpred) / (exp(linpred) + 1)   #this is the inverse logit function
dimnames(fitted.det)[[2]] <- detection_data_specieslist
fitted.det <- as_tibble(fitted.det)
fitted.det$SiteID <- detection_data$SiteID

fitted.obsprob <- (fitted.occ %>%
  right_join(fitted.det %>% dplyr::select("SiteID"), by = "SiteID") %>%
  dplyr::select(-SiteID)) *
  (fitted.det %>% dplyr::select(-SiteID))
```

```{r fittedprob_onaverage, fig.height = 10}
colMeans(fitted.obsprob) %>%
  enframe() %>%
  inner_join(enframe(colMeans(detection_data[, detection_data_specieslist])),
             by = "name", suffix = c(".fit", ".obs")) %>%
  pivot_longer(-name, names_to = "type", values_to = "value") %>%
  ggplot() +
  geom_bar(aes(y = name, x = value, fill = type), stat = "identity", position = "dodge") +
  ggtitle("Mean Fitted Detection Probability Across All Sites") +
  scale_color_viridis_d()
```

On average the fitted probability does very poorly. I thought it would do better considering it could use unique intercept for each species (up to the random effect restriction).
The Australian Magpie is an example. Wow! It is bad!

```{r particularspecies}
specname <- "Weebill"# detection_data_specieslist[[1]]
aspecies <- tibble(obs = detection_data[, specname], 
                   fit = fitted.obsprob[, specname])
aspecies %>%
  arrange(fit) %>%
  rowid_to_column() %>%
  ggplot() +
  geom_point(aes(x = rowid, y = obs), position = "jitter") +
  geom_line(aes(x = rowid, y = fit), col = "blue", lwd = 2) +
  ggtitle(specname)

specname <- "Sacred Kingfisher"# detection_data_specieslist[[1]]
aspecies <- tibble(obs = detection_data[, specname], 
                   fit = fitted.obsprob[, specname])
aspecies %>%
  arrange(fit) %>%
  rowid_to_column() %>%
  ggplot() +
  geom_point(aes(x = rowid, y = obs), position = "jitter") +
  geom_line(aes(x = rowid, y = fit), col = "blue", lwd = 2) +
  ggtitle(specname)
```


Ok so even though the fitted coefficients made sense, the actual predictions are really really poor.

## Improvements
* Higher thinning rate so that there is less autocorrelation in the occupancy coefficient samples.
* Track the LV values outside R, possibly using noread.monitor if it is too costly to include with rest of fitted parameters.
* A way to enable more LVs without doing some clustering of species first - i.e. how to use the method to *find* clusters?


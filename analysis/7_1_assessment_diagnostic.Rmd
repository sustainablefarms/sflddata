---
title: "Diagnostic and Assesment of 7_1 model"
author: "Kassel Hingee"
date: "25/03/2020"
runtime: shiny
output: 
  html_document: 
    toc: yes
---

```{r setup, include=FALSE}
library(MCMCpack)
library(mclust)
library(corrplot)
library(R2jags)
```

```{r importdata, echo = FALSE}
# setwd("..")
source("./scripts/7_1_import_site_observations.R")
fit <- readRDS("./tmpdata/7_1_mcmcchain_20200325.rds")
```

Note that only the following, very common, species were included for this model `detection_data_specieslist`.


## Diagnostics of MCMC Chain Convergence
### Traces
```{r chaindiagnostics1, echo = FALSE}
medians <- fit$BUGSoutput$median
traceofvar <- function(x, varname, dimsval, lty = 1, lwd = 1, col = c("red", "green", "blue"), ...){
   #copied from: selectMethod(traceplot, "rjags.parallel")
    x <- fit$BUGSoutput
    n.chain <- x$n.chains
    n.keep <- x$n.keep
    bugs.array <- x$sims.array
    if (is.null(dimsval)) {v.name <- varname}
    else {v.name <- paste0(varname, "[",paste0(dimsval, collapse = ","), "]")}
    index <- grep(v.name, dimnames(bugs.array)[[3]], fixed = TRUE)
    range.x <- c(1, n.keep)
    range.y <- range(bugs.array[, , index])
    par(ask = FALSE)
    plot(range.x, range.y, type = "n", main = v.name, 
        xlab = "iteration", ylab = v.name, xaxt = "n", 
        xaxs = "i")
    for (i in 1:n.chain) {
        x.cord <- 1:n.keep
        y.cord <- bugs.array[, i, index]
        lines(x.cord, y.cord, col = col[i], lty = lty, 
          lwd = lwd)
    }
    axis(1, at = seq(0, n.keep, n.keep * 0.1), tick = TRUE)
}

shinyApp(
  ui = fluidPage(
    column(4, radioButtons("varname", label = "Variable Name:",
                 choices = unique(gsub("\\[.*\\]", "", dimnames(fit$BUGSoutput$sims.array)[[3]])),
                 selected = "u.b")),
    column(8, list(
    uiOutput("dim1"),
    uiOutput("dim2"),
    uiOutput("dim3"))),
    plotOutput("theplot", height = "400px")
  ),
  server = function(input, output){
    output$dim1 <- renderUI({
      dims <- dim(medians[[input$varname]])
      sliderdims <- c(1, 1, 1)
      sliderdims[1:length(dims)] <- dims
      sliderInput("dim1", label = paste0("Dimension 1 of ", input$varname),
                 min = 1, max = sliderdims[[1]], value = 1, step = 1)
    })
    output$dim2 <- renderUI({
      dims <- dim(medians[[input$varname]])
      sliderdims <- c(1, 1, 1)
      sliderdims[1:length(dims)] <- dims
      sliderInput("dim2", label = paste0("Dimension 2 of ", input$varname),
                 min = 1, max = sliderdims[[2]], value = 1, step = 1)
    })
    output$theplot <- renderPlot(height = 400, {
      dims <- dim(medians[[input$varname]])
      dimselect <- as.vector(as.numeric(c(input$dim1, input$dim2)))[1:length(dims)]
      if (input$varname == "deviance"){dimselect <- NULL}
      traceofvar(fit, input$varname, dimselect)
      })
  },
  options = list(height = 1000)
)
```

Above is an interactive method allowing plotting of the trace of each variable. 
#### Observations
+ LV[,2] parameters can differ substantially between traces, which suggests that the fitted model has depended heavily on the initial conditions.
  + these values were initiated with matrix(rnorm(nlv*J),J,nlv)
+ deviance convegence looks good
+ lv.coef values show dependence between samples --> larger thinning valuable. lv.coef[10, 1], lv.coef[15, 1] and have different distributions for each chain.
+ mu.u.b, mu.v.b and tau.u.b all appear like white noise 
+ tau.v.b appears to have some dependence between samples
+ u.b samples are also dependent
+ z  I don't know how to assess z. It has values of either 0 or 1. It isn't a parameter of interest to model quality either.

### A Default Summary from R2WinBugs
```{r R2WinBugs}
plot(fit, display.parallel = TRUE)
#see behaviour: getS3method("plot","rjags")
# leads to:     getS3method("plot","bugs")
```

The large Rhat values for lv.coef are consistent with the differences between chains noticed above.
There are many components of the parameters not shown.**would be nice to show more!

tau.v.b for midstorey and overstorey cover have really large intervals compared to everything else. Could be due to the lack of scaling.

```{r R2winbugs2_fail, include = FALSE, eval = FALSE}
keeponlyvar <- function(bugsoutput, varname) {
  varidx <- grep(varname, bugsoutput$root.short)
  keepidx <- bugsoutput$long.short[[varidx]]
  
  bugsoutput$sims.array <- bugsoutput$sims.array[, , keepidx]
  bugsoutput$sims.list <- bugsoutput$sims.list[[varidx]]
  bugsoutput$sims.matrix <- bugsoutput$sims.matrix[, keepidx]
  
  bugsoutput$long.short <- list(1:length(keepidx))
  bugoutput$root.short <- list(varname)
  
  return(bugsoutput)
}
fitsub <- keeponlyvar(fit$BUGSoutput, "lv.coef")
plot(fitsub)
```

### Further Analysis with help from ggmcmc
```{r }



```{r ggmcmc1}
library(ggmcmc)
fit.ggs <- ggs(coda::as.mcmc(fit), family = "(lv.coef)|(mu)", sort = TRUE)
ggs_caterpillar(fit.ggs)
ggs_density(fit.ggs) + facet_wrap(~ Parameter)
ggs_Rhat(fit.ggs) + xlab("R_hat")
ggs_geweke(fit.ggs)
ggs_compare_partial(fit.ggs, family = "lv.coef\\[.,1\\]")
ggs_compare_partial(fit.ggs, family = "lv.coef\\[.,2\\]")
ggs_crosscorrelation(fit.ggs)
ggs_pairs(fit.ggs, lower = list(continuous = "density"))

ggs_rocplot(fit.ggs, outcome = "y")

ggs_autocorrelation(fit.ggs, family = "lv.coef\\[.,1\\]") +
  facet_wrap(~ Parameter) +
  aes(fill = NULL, alpha = 0)
```


### Correlation Between Variables

### Autocorrelation of Samples (should be close to zero)

### Compare to chains with very different initial conditions

### Other Diagnostics of Whether Model has Updated Successfully?

## Assess Model




## Impovements
* There is an interpretation difficulty due to the inputs being unscaled and uncentred.
* Keep burn in and don't do any thinning - to see effect of initial conditions, and of thinning
* Do fewer iterations to make for faster assessment
* More species
* Reduce plotting of per-site parameters of no interest (mainly z?)
* Track final probability of detection 'mu.p' - to compare with actual observations.


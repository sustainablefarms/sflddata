---
title: 'Modelling GPP: gams and interactions'
author: "Kassel Hingee"
date: "16/01/2020"
output: 
  html_document: 
    toc: yes
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(echo = TRUE)
out <- lapply(c("sf", "tsibble", 'lubridate', "viridis",
                'ggplot2', 'tidyr', 'grid', 'gridExtra', 
                'feasts', 'dplyr', 'gtable', 'fable',
                'mgcv'),
       library, character.only = TRUE)
out <- lapply(paste0("../functions/", list.files("../functions/")), source)
```

*Proposal:* high rate of change in GPP will correspond to spikes. For gpp sufficiently high, grazing is increased to maximise profits and the GPP increase is slower. This suggests a model for the rate of GPP change as a function of current/previous GPP, day of the year, and recent rainfall, with interactions between all of these.

+ high GPP ==> low rate of GPP increase regardless of other covariates
+ high rainfall and low GPP ==> high rate of GPP increase
+ moderate rainfall, spring and low GPP ==> moderate rate of GPP increase

Modelling Paradigm:
Response is: GPP, not seasonally corrected.
Predictors:

1. last years GPP or average GPP
2. most recent GPP
3. cumulative rainfall at 1d, 7d, 15d, 1m, 2m, 3m, 5m, 8m, 14m to avoid having to include interactions between rainfall terms
4. day of the year
5. farm


```{r preparedata}
#load data and convert to tsibbles
load("../private/data/remote_sensed/pg_daily.Rdata")
pg_daily$times <- as_date(pg_daily$times)
pg <- pg_daily %>%
  pivot_longer(-times, names_to = "site", values_to = "pg") %>%
  as_tsibble(key = site, index = times)
load("../private/data/remote_sensed/gpp_8d.Rdata")
gpp <- gpp_8d %>%
  pivot_longer(-times, names_to = "site", values_to = "gpp") %>%
  as_tsibble(key = site, index = times)
pggpp <- as_tsibble(dplyr::full_join(pg, gpp, by = c("times", "site")), key = site, index = times)

# add times breakdowns
pggpp <- pggpp %>%
  mutate(yday = yday(times),
         year = year(times))
  

#interpolate gpp
pggpp <- pggpp %>%
  group_by_key() %>% #key is site
  mutate(lininterp_gpp = zoo::na.approx(gpp, rule = 2, na.rm = FALSE)) %>% #rule 2 means edges are assigned last value
  ungroup()

#make sure sites are ordered alphabetically
pggpp <- pggpp %>%
  arrange(site) %>%
  mutate(site = factor(site, ordered = TRUE))

#separate alpha part of site code
pggpp <- pggpp %>%
  mutate(farm = factor(substr(site, 1, 4)),
         sitenum = factor(as.integer(substr(site, 5, 5))))


# Add cumulative rainfalls
pggpp <- pggpp %>% 
  group_by_key() %>%
  mutate(pg_cumsum = cumsum(pg)) %>%
  mutate(pg_1to7 = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 8), # 1 up to 8 days behind (excluding 8th day)
         pg_1to15 = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 16), # 1 to 16 days behind
         pg_1to1m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 31),
         pg_1to2m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 2*31),
         pg_1to3m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 3*31),
         pg_1to4m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 4*31),
         pg_1to5m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 5*31),
         pg_1to6m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 6*31),
         pg_1to7m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 7*31),
         pg_1to8m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 8*31),
         pg_1to10m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 10*31),
         pg_1to12m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 12*31),
         pg_1to14m = lag(pg_cumsum, n = 1) - lag(pg_cumsum, n = 14*31),
         ) %>%
  ungroup()

# simple mean gpp of training years
ydaymeangpp <- pggpp %>%
  filter(yday %in% seq(1, 366, by = 8)) %>%
  group_by(site) %>%
  index_by(yday) %>%
  summarise(gpp.ydaymean = mean(gpp))
pggpp <- left_join(pggpp, ydaymeangpp, by = c("site", "yday"))
```

```{r preparetraintest}
train <- pggpp %>%
  filter(yday %in% seq(1, 366, by = 8)) %>%
  filter(sitenum == 1) %>% #so not doubling up at farms
  filter_index(. ~ "2016-12-31") %>%
  select(-pg_cumsum, -lininterp_gpp) %>%
  mutate(gpp = if_else(gpp < 0.1, as.double(NA), gpp)) #remove outlying GPP values that are super low

test <- pggpp %>%
  filter_index("2017-01-01" ~ .) %>%
  filter(sitenum == 1) %>% #so not doubling up at farms
  filter(yday %in% seq(1, 366, by = 8)) %>%
  select(-pg_cumsum)
```


In the above very small GPP values have been removed. There was `r sum(is.na(train$gpp))` of them, which corresponds to `r sum(is.na(train$gpp)) / length(train$gpp)` of the data.

## Model Fit of GAM with interactions between precipitation and seasonal gpp.
In first attempts to fit model, fitting the whole data set at once did not complete. In the following I try to fit the same model, but separate model for each farm. Hopefully the parameters of each model for each farm will be comparable.

First is a periodic gam with log link and using yday as a substitute for seasonal GPP.
```{r m1}
m1_bell1 <- gam(gpp ~  gpp.ydaymean +
                 #s(yday, bs = "cc", k = 20) + #substitute for using seasonal gpp
                 s(pg, gpp.ydaymean) +
                 s(pg_1to7, gpp.ydaymean) + 
                 s(pg_1to15, gpp.ydaymean) +
                 s(pg_1to1m, gpp.ydaymean) +
                 s(pg_1to2m, gpp.ydaymean) +
                 s(pg_1to3m, gpp.ydaymean) +
                 s(pg_1to5m, gpp.ydaymean) +
                 s(pg_1to8m, gpp.ydaymean) +
                 s(pg_1to14m, gpp.ydaymean)
                 ,
             family = gaussian(link = "log"),
             data = train %>% filter(site == "BELL1"))
train %>%
  filter(site == "BELL1") %>%
  tibble::rownames_to_column() %>%
  left_join(tibble::enframe(predict(m1_bell1, type = "response"), name = "rowname", value = "gpp.fitted"),
            by = "rowname") %>%
  filter_index("2005" ~ .) %>%
  pivot_longer(c("gpp.fitted", "gpp")) %>%
  ggplot() +
  geom_line(aes(x = times, y = gpp.ydaymean), alpha = 0.3) +
  geom_line(aes(x = times, y = value, col = name, lty = name), size = 0.5) +
  geom_point(aes(x = times, y = value, col = name, shape = name), size = 1) +
  ggtitle("m1 for bell1: fitted values") +
  scale_color_viridis_d()

plot(m1_bell1, scheme = 2)
m1_bell1
gam.check(m1_bell1)
```


The model predictions are better than the linear fits I did previously. The peaks were not modelled well initially and interpretation was obfuscated by the lag(gpp) use of seasonal gpp; here the seasonal gpp is using the mean across all training years instead.

The smooths of interactions between gpp.ydaymean and the cumulative rainfall have contours that run nearly vertical, suggesting that there was not much interaction between gpp.ydaymean and the cumulative rainfalls.

The residuals are not at all i.i.d. There appears to be quite a sharp striation of residuals in the resdiual vs linear predictor plot.

A lot of the edf vales are very close to k'. I think this is reason to suspect something.


The following uses `bam()`, which is like gam but designed for larger amounts of data.
```{r m1_allfarms}
m1 <- bam(gpp ~  gpp.ydaymean +
                 farm +
                 #s(yday, bs = "cc", k = 20) + #substitute for using seasonal gpp
                 #s(pg, gpp.ydaymean) +
                 #s(pg_1to7, gpp.ydaymean) + 
                 #s(pg_1to15, gpp.ydaymean) +
                 #s(pg_1to1m, gpp.ydaymean) +
                 #s(pg_1to2m, gpp.ydaymean) +
                 #s(pg_1to3m, gpp.ydaymean) +
                 s(pg_1to5m, gpp.ydaymean, by = farm) 
                 #s(pg_1to14m, gpp.ydaymean)
                 ,
             family = gaussian(link = "log"),
             data = train %>% filter(sitenum == 1))
plot(m1)
summary(m1)

train %>%
  filter(sitenum == 1) %>%
  tibble::rownames_to_column() %>%
  left_join(tibble::enframe(predict(m1, type = "response"), name = "rowname", value = "gpp.fitted"),
            by = "rowname") %>%
  filter(farm == "BELL") %>%
  filter_index("2005" ~ .) %>%
  pivot_longer(c("gpp.fitted", "gpp")) %>%
  ggplot() +
  geom_line(aes(x = times, y = gpp.ydaymean), alpha = 0.3) +
  geom_line(aes(x = times, y = value, col = name, lty = name), size = 0.5) +
  geom_point(aes(x = times, y = value, col = name, shape = name), size = 1) +
  ggtitle("m1: fitted values at BELL1") +
  scale_color_viridis_d()
```


## Fit a GAM with autocorrelated errors
```{r m2, eval = FALSE}
m2_bell1 <- gamm(gpp ~  gpp.ydaymean +
                 #s(yday, bs = "cc", k = 20) + #substitute for using seasonal gpp
                 # s(pg, gpp.ydaymean) +
                 # s(pg_1to7, gpp.ydaymean) + 
                 # s(pg_1to15, gpp.ydaymean) +
                 # s(pg_1to1m, gpp.ydaymean) +
                 # s(pg_1to2m, gpp.ydaymean) +
                 s(pg_1to3m, gpp.ydaymean) +
                 s(pg_1to5m, gpp.ydaymean) 
                 # s(pg_1to8m, gpp.ydaymean) +
                 # s(pg_1to14m, gpp.ydaymean)
                 ,
             family = gaussian(link = "log"),
             correlation = corARMA(p = 1, q = 1, form = ~times),
             data = train %>% filter(site == "BELL1"))
```

Fitting attempts fo the above failed due to 'Singularity in backsolve at level 0, block 1' in the MEestimate function.
Do not know what is causing this, or how to avoid it.

## Fit a GAMM without correlated errors
I've chosen to use just pg_1to5m as this and pg_1to8m were the only rainfall covariates that had an (untrustworthy anyway) small $p$ value.

```{r m3}
m3 <- gamm(gpp ~  s(pg_1to5m),
             random = list(site = ~1 + pg_1to5m),
             family = gaussian(link = "log"),
             data = train %>% filter(sitenum == 1, !is.na(pg_1to5m)) )
plot(m3$gam)
plot(m3$lme)
ranef(m3$lme)
m3
```

A model was fitted successfully, but I've no idea how to assess the model quality.
The smooth fit for pg_1to5m seems appropriate, shape: the impact of rain flattens out after 400mm (which is an incredible amount of rain).

What is the 'g'-level random effect? A: related to the smoothing

*Why do the site codes have '1' in front of them?* 
*what does the warning about non-contrast terms mean?*

I'm also not entirely sure if the random effect is acting on the spline or on a separate linear term. Below is the prediction as if the random effect is action on separate linear terms. 

The package `mgcv` can take random effects in `gam()` through `s()`, need to look into this more.

```{r m3_assess_predictions}
pred <- train %>% filter(sitenum == 1, !is.na(pg_1to5m)) %>% tibble::rownames_to_column(var = "rowname")
pred <- pred %>%
  left_join(tibble::enframe(predict(m3$gam, type = "response"), name = "rowname", value = "gam.predict"),
            by = "rowname")
pred %>%
  filter(site == "BELL1") %>%
  mutate(gamm.predict = gam.predict + sum(ranef(m3$lme, level = 2)["1/BELL1", ] * c(1, pg_1to5m)) ) %>%
  pivot_longer(c(gamm.predict, gam.predict, gpp)) %>%
  ggplot() +
  geom_point(aes(x = times, y = value, col = name, shape = name))
```

```{r m3_assessment_ranintercepts}
library(ggrepel) # for adding text labels at nice locations
ranef(m3$lme, level = 2) %>%
  as_tibble(rownames = "site") %>%
  ggplot() +
  geom_point(aes(x = `(Intercept)`, y = pg_1to5m)) +
  geom_text_repel(aes(x = `(Intercept)`, y = pg_1to5m, label = gsub("1/", "", site)),
              inherit.aes = TRUE,
              size = 3)
```


## Fit model aimed at GPP spikes
```{r m4}

```
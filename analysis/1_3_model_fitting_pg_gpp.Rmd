---
title: "Response of GPP to PG: modelling"
author: "Kassel Hingee"
date: "20/12/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
out <- lapply(c("sf", "tsibble", 'lubridate', "viridis",
                'ggplot2', 'tidyr', 'grid', 'gridExtra', 
                'feasts', 'dplyr', 'gtable', 'fable'),
       library, character.only = TRUE)
out <- lapply(paste0("../functions/", list.files("../functions/")), source)
```

```{r preparedata}
#load data and convert to tsibbles
load("../private/data/remote_sensed/pg_daily.Rdata")
pg_daily$times <- as_date(pg_daily$times)
pg <- pg_daily %>%
  pivot_longer(-times, names_to = "site", values_to = "pg") %>%
  as_tsibble(key = site, index = times)
load("../private/data/remote_sensed/gpp_8d.Rdata")
gpp <- gpp_8d %>%
  pivot_longer(-times, names_to = "site", values_to = "gpp") %>%
  as_tsibble(key = site, index = times)
pggpp <- as_tsibble(dplyr::full_join(pg, gpp, by = c("times", "site")), key = site, index = times)
pggpp <- pggpp %>%
  mutate(yday = yday(times)) %>%
  group_by_key() %>% #key is site
  mutate(lininterp_gpp = zoo::na.approx(gpp, rule = 1, na.rm = FALSE))
```

## Model Proposition 1 and 2:
Let us assume that:
  1. On any day of the year at a given location that some GPP is occuring purely due to the season and properties that are constant for the location:
     + amount of woody veg,
     + types of trees,
     + climatic variables,
     + soil
     + more
  2. There is an increase of GPP in response to rainfall

The first items above can be represented single function that depends on day of the year and location, and not on the year, nor on the amount of rain. The model could be of two forms:
\[
\begin{aligned}
M1: && Y_i(t) = s_i(t_{yr}) \times g\big(r_i(t), r_i(t-1), r_i(t-2), r_i(t-3), ...\big) \times \epsilon_i(t)\\
M2: && Y_i(t) = s_i(t_{yr}) + g\big(r_i(t), r_i(t-1), r_i(t-2), r_i(t-3), ...\big) + \epsilon_i(t)
\end{aligned}
\]
where 
+ $Y_i(t)$ is the GPP at location $i$ on date $t$,
+ $t_{yr}$ is the date modulo year,
+ $s_i(t_{yr})$ is the amount of GPP due to factors that are constant across years,
+ $g$ is a function independent of location,
+ $r_i(t)$ the rain at location $i$ on day $t$,
+ $\epsilon_i(t)$ is a random process with some autodependence (*distribution yet to be specified*).

The interest is in:
 1. Does the model fit well?
 2. Do the properties of $\epsilon_i$ depend on grazing intensity?
    + and are they related to biodiversity?
 3. Is it possible to predict GPP in advance? 

The form and parameters of $s_i$ are not of interest.

*another alternative would be to include a lag term in $g$ that depends on location*

### Wrinkles with these models
+ amount of woody veg changes each year - e.g. forest planted, forest removed, fire
+ at very very dry times plants die and may not recover

## Model Fitting
Suppose *independent* observations $y_i^j(t_j)$, $j = 1, 2, ...., n_i$, for each location $i$.
At this point we can think of these observations of random variables $Y_i^j(t_j)$.
The likelihood of $y_i^j(t_j)$ assuming $M1$ is:
\[
\begin{align}
& \mathcal{L} (\theta | y_i^j(t_j), j = 1,..., i = 1, ...) \\
=& f_\theta(Y_i^j(t_j) = y_i^j(t_j), j = 1,..., i = 1, ...)\\
=& \prod_{i, j} f_\theta\big(Y_i^j(t_j) = y_i^j(t_j)\big)\\
=& \prod_{i, j} f_\theta\left(\epsilon_i(t) =  \frac{y_i^j(t_j)}{ s_i(t_{j, yr}) \times g\big(r_i(t_j), r_i(t_j-1), r_i(t_j-2), r_i(t_j-3), ...\big) }\right)\\
=& \prod_{i, j} f_{i, \theta}\left(\frac{y_i^j(t_j)}{ s_i(t_{j, yr}) \times g\big(r_i(t_j), r_i(t_j-1), r_i(t_j-2), r_i(t_j-3), ...\big) }\right)
\end{align}
\]
where the final $f_{i, \theta}$ are the probability density functions of $\epsilon_i$.
If $\epsilon_i(t)$ is a Gaussian distribution at a given time point,
\[
\begin{align}
& f_{i, \theta}\left(\frac{y_i^j(t_j)}{ s_i(t_{j, yr}) \times g\big(r_i(t_j), r_i(t_j-1), r_i(t_j-2), r_i(t_j-3), ...\big) }\right)\\
=& \frac{1}{\sigma_i \sqrt{2\pi}} \exp\left(-\frac{1}{2} \left( \frac{y_i^j(t_j)}{ \sigma_i s_i(t_{j, yr}) g\big(r_i(t_j) ...\big)} \right)^2 \right)
\end{align}
\]
So the likelihood of $y_i^j(t_j)$ is
\[
\begin{align}
&\prod_{i, j} f_{i, \theta}\left(\frac{y_i^j(t_j)}{ s_i(t_{j, yr}) \times g\big(r_i(t_j), r_i(t_j-1), r_i(t_j-2), r_i(t_j-3), ...\big) }\right)\\
=& \prod_{i, j} \frac{1}{\sigma_i \sqrt{2\pi}} \exp\left(\sum_{i, j}  \frac{y_i^j(t_j)}{ \sigma_i s_i(t_{j, yr}) g\big(r_i(t_j) ...\big)}\right) 
\end{align}
\]


### Fully Parametric
+ $\epsilon_i(t)$ is autocorrelated and has a mean of zero.
  + (according to (Ostrom, 2011, https://dx.doi.org/10.4135/9781412986366: Time Series Regression Analysis: Lagged Case) the OLS estimates are not consistent)
+ Generalised Least Squares?

### Semi-Parametric
+ do not fit $s_i$ at all. 

## Models 3 and 4:
Let us assume that:
  1. On any day of the year at a given location that some GPP is occuring purely due to the season and properties that are change slowly, taking multiple years to change:
     + amount of woody veg,
     + types of trees,
     + climatic variables,
     + soil
     + more
  2. There is an increase of GPP in response to rainfall

The first items above can be represented single function that depends on GPP on the same day of the year for previous years and not on the amount of rain. The model could be of two forms:
\[
\begin{aligned}
M1: && Y_i(t) = \big(\theta_1 Y_i(t - 1yr) +  \theta_2Y_i(t - 2yr) +  \theta_3Y_i(t - 3yr) +  \theta_4Y_i(t - 4yr) + ...\big)\times\\
&& \quad\quad\quad\quad\quad g\big(r_i(t), r_i(t-1), r_i(t-2), r_i(t-3), ...\big) \times \epsilon_i(t)\\
M2: && Y_i(t) = \big(\theta_1 Y_i(t - 1yr) +  \theta_2Y_i(t - 2yr) +  \theta_3Y_i(t - 3yr) +  \theta_4Y_i(t - 4yr) + ...\big) +\\
&& \quad\quad\quad\quad\quad  g\big(r_i(t), r_i(t-1), r_i(t-2), r_i(t-3), ...\big) + \epsilon_i(t)
\end{aligned}
\]
where 
+ $Y_i(t)$ is the GPP at location $i$ on date $t$,
+ $t_{yr}$ is the date modulo year,
+ $s_i(t_{yr})$ is the amount of GPP due to factors that are constant across years,
+ $g$ is a function independent of location,
+ $r_i(t)$ the rain at location $i$ on day $t$,
+ $\epsilon_i(t)$ is a random process with some autodependence (*distribution yet to be specified*).

The interest is in:
 1. Does the model fit well?
 2. Do the properties of $\epsilon_i$ depend on grazing intensity?
    + and are they related to biodiversity?
 3. Is it possible to predict GPP in advance? 

### Model fitting
It seems like `stats::arima` will fit ARIMA model including regressors! This could be applied to a single site. I'm not sure how to pool the data so that it is applied to all sites. 

'linear regression is fitted with an ARMA for the error term': 
Cryer and Chan (Section 11.3) suggest that it makes more sense to fit this sort of model than 
$Y_t = \beta_0 + \beta_1 X__{t-d} + \epsilon_t$ as the latter is prone to correlation between the $Y_t$ and $X_t$.

Note a `tsibble` can be converted into a `ts` using `tsibble::as.ts.tbl_ts`

Below fits linearly-interpolated GPP to rainfall and GPP of previous years for a single site. 
This is just a practise with the methods. Proper method will need to avoid fitting to linearly interpolated response variables, and also us all sites (interrupted time series data?).

Using base R and `ts` objects
```{r fitlininterpGPP_ts}
#create lagged PG columns so that xreg works
bell1 <- pggpp %>%
  filter(site == "BELL1")

#split data into training and test (80%, 20%) with test being the final 2 years of data
bell1_train <- bell1 %>%
  filter_index(. ~ "2016-12-31")
bell1_test <- bell1 %>%
  filter_index("2017-01-01" ~ .)

bell1_train_ts <- as.ts(bell1_train, value = gpp, frequency = 365.25)
# specify 365.25 time points per unit of time. So 1 unit of time = 1 year

#use fourier() to avoid the maximum lag = 350 warning
onlyseasonal <- arima(bell1_train_ts, xreg = forecast::fourier(bell1_train_ts, K = 10))
onlyseasonal
pred <- predict(onlyseasonal, n.ahead = 700,
        newxreg = forecast::fourier(bell1_train_ts, K = 10, h = 700),
        )
pred <- inner_join(as_tsibble(pred$pred),
           as_tsibble(pred$se),
           by = "index")
names(pred) <- c("index", "pred", "se")

pred %>%
  index_by(day = date(index)) %>%
  ggplot() +
  geom_ribbon(aes(x = day, ymin = pred - 2 * se, ymax = pred + 2 * se)) +
  geom_line(aes(x = day, y = pred))

```

Fit a AR model (no MA component) using package `fable`.
```{r fitlininterpGPP_bell1}
bell1 <- pggpp %>%
  filter(site == "BELL1")
#split data into training and test (80%, 20%) with test being the final 2 years of data
bell1_train <- bell1 %>%
  filter_index(. ~ "2016-12-31")
bell1_test <- bell1 %>%
  filter_index("2017-01-01" ~ .)

modelfmla1 <- reformulate(c(paste0("lag(lininterp_gpp, n = ", (1:5)*365.25, ")"),
                           "trend()",
                           "pdq(0, 0, 0)",
                           "PDQ(0, 0, 0)",
                           paste0("lag(pg, n = ", 1:60, ")")),
                           response = "gpp")
modelfmla2 <- reformulate(c(paste0("lag(lininterp_gpp, n = ", (1:5)*365.25, ")"),
                           "trend()",
                           "pdq(0, 0, 0)",
                           "PDQ(0, 0, 0)"),
                           response = "gpp")

fitbell1 <- bell1_train %>%
  ungroup() %>%
  model(withpg = ARIMA(modelfmla1), nopg = ARIMA(modelfmla2))

# plot forecasts for test data
fitbell1 %>%
  forecast(new_data = bell1_test) %>%
  mutate(interval = hilo(.distribution, 95)) %>%
  ggplot() +
  facet_grid(rows = vars(.model)) +
  geom_ribbon(aes(x = times, ymin = interval$.lower, ymax = interval$.upper), fill = "lightgrey") +
  geom_line(aes(x = times, y = gpp), col = "black") + 
  geom_point(aes(x = times, y = gpp), data = bell1_test, col = "blue")
```

The forecasts using precipitation do appear to be slightly better for Bell1. But individually each day of precipitation does not add much (as the following plot of estimates suggests).

```{r investigatefitbell1}
fitbell1 %>%
  tidy() %>%
  mutate(term = factor(term, levels = labels(terms(modelfmla1)), ordered = TRUE)) %>%
  ggplot() +
  geom_pointrange(aes(x = term, ymin = estimate - 2 * std.error, ymax = estimate + 2 * std.error, y = estimate),
                  stat = "identity", fatten = 0.5) +
  facet_grid(rows = vars(.model)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

```


### Fit one model to all sites
Using 60 days in the above unresricted manner is too slow for fiiting to all sites. So instead of just lag, will also add some smoothing. 

```{r fittosmoothedpg}
modelfmla3 <- reformulate(c(paste0("lag(lininterp_gpp, n = ", (1:2)*365.25, ")"),
                           "trend()",
                           "pdq(0, 0, 0)",
                           "PDQ(0, 0, 0)",
                           paste0("lag(slide_dbl(pg, sum, .size = 7, .align = 'r'), n = ", 7 * (0:9), ")")),
                           response = "gpp")
modelfmla4 <- reformulate(c(paste0("lag(lininterp_gpp, n = ", (1:5)*365.25, ")"),
                           "trend()",
                           "pdq(0, 0, 0)",
                           "PDQ(0, 0, 0)",
                           paste0("lag(slide_dbl(pg, sum, .size = 7, .align = 'r'), n = ", 7 * (0:9), ")")),
                           response = "gpp")

fitbell3 <- bell1_train %>%
  ungroup() %>%
  model(withpg_bin7 = ARIMA(modelfmla3), withpg_bin7_hist7 = ARIMA(modelfmla4))


# plot forecasts for test data
fitbell3 %>%
  forecast(new_data = bell1_test) %>%
  rbind(forecast(fitbell1, new_data = bell1_test)) %>%
  mutate(interval = hilo(.distribution, 95)) %>%
  ggplot() +
  facet_grid(rows = vars(.model)) +
  geom_ribbon(aes(x = times, ymin = interval$.lower, ymax = interval$.upper), fill = "lightgrey") +
  geom_line(aes(x = times, y = gpp), col = "black") + 
  geom_point(aes(x = times, y = gpp), data = bell1_test, col = "blue")


fitbell3 %>%
  tidy() %>%
  mutate(term = factor(term, levels = labels(terms(modelfmla4)), ordered = TRUE)) %>%  #makes sure plot is maintains order of terms
  ggplot() +
  #geom_bar(aes(x = term, y = estimate), stat = "identity") +
  geom_pointrange(aes(x = term, ymin = estimate - 2 * std.error, ymax = estimate + 2 * std.error, y = estimate),
                  stat = "identity", fatten = 0.5) +
  facet_grid(rows = vars(.model)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```



Attempt to fit one model to all sites. Fable fits the same model form to each site automatically. To cheat this method I will shift each site's observation times back by 30 years and remove the trend term.

```{r fitlininterpGPP}
pggpp_train <- pggpp %>%
  filter_index(. ~ "2016-12-31")
pggpp_test <- pggpp %>%
  filter_index("2017-01-01" ~ .)

pggpp_train <- pggpp_train %>%
 mutate(siteindx = as.numeric(factor(site, levels = unique(pggpp$site)))) %>%
 mutate(alttimes = times - days(366 * 30 * siteindx)) %>% #can't use year periods due to leap years
 ungroup() %>%
 update_tsibble(key = NULL, index = "alttimes") %>%
 fill_gaps()

fit_pivotedsites <- pggpp_train %>%
  model(ARIMA(modelfmla4))

# plot forecasts for test data
fit_pivotedsites %>%
  forecast(new_data = pggpp %>% 
             filter(site == "BELL1") %>% 
             update_tsibble(key = NULL, index = "times")
           ) %>%
  filter_index("2017-01-01" ~ .) %>%
  mutate(interval = hilo(.distribution, 95)) %>%
  ggplot() +
  geom_ribbon(aes(x = times, ymin = interval$.lower, ymax = interval$.upper), fill = "lightgrey") +
  geom_line(aes(x = times, y = gpp), col = "black") + 
  geom_point(aes(x = times, y = gpp), data = pggpp_test %>% filter(site == "BELL1"), col = "blue")
```

```{r fitcoefs}
fit_pivotedsites %>%
  tidy() %>%
  ggplot() +
  mutate(term = factor(term, levels = labels(terms(modelfmla4)), ordered = TRUE)) %>%  #makes sure plot is maintains order of terms
  #geom_bar(aes(x = term, y = estimate), stat = "identity") +
  geom_pointrange(aes(x = term, ymin = estimate - 2 * std.error, ymax = estimate + 2 * std.error, y = estimate),
                  stat = "identity", fatten = 0.5) +
  facet_grid(rows = vars(.model)) +
  ylim(c(-0.1, 0.5)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

tidy(fit)
```

It looks like precipitation has very little effect in the model for the tested years.

Lots of model diagnostics required. Perhaps failures of the prediction are due to model form.


### Log Linear Model
```{r loglinear}
pggpp_train <- pggpp %>%
  filter_index(. ~ "2016-12-31")
pggpp_test <- pggpp %>%
  filter_index("2017-01-01" ~ .)

pggpp_train <- pggpp_train %>%
 mutate(siteindx = as.numeric(factor(site, levels = unique(pggpp$site)))) %>%
 mutate(alttimes = times - days(366 * 30 * siteindx)) %>% #can't use year periods due to leap years
 ungroup() %>%
 update_tsibble(key = NULL, index = "alttimes") %>%
 fill_gaps()

modelfmla5 <- reformulate(c(paste0("lag(log(lininterp_gpp + 0.01), n = ", (1:5)*365.25, ")"),
                           "pdq(0, 0, 0)",
                           "PDQ(0, 0, 0)",
                           paste0("lag(slide_dbl(pg, sum, .size = 7, .align = 'r'), n = ", 7 * (0:9), ")")),
                           response = "log(gpp + 0.01)")
fit_loglin <- pggpp_train %>%
  model(ARIMA(modelfmla))

# plot forecasts for test data
fit_loglin %>%
  forecast(new_data = pggpp %>% 
             filter(site == "BELL1") %>% 
             update_tsibble(key = NULL, index = "times")
           ) %>%
  filter_index("2017-01-01" ~ .) %>%
  mutate(interval = hilo(.distribution, 95)) %>%
  ggplot() +
  geom_ribbon(aes(x = times, ymin = interval$.lower, ymax = interval$.upper), fill = "lightgrey") +
  geom_line(aes(x = times, y = gpp), col = "black") + 
  geom_point(aes(x = times, y = gpp), data = pggpp_test %>% filter(site == "BELL1"), col = "blue")

fit_loglin %>%
  tidy() %>%
  mutate(term = factor(term, levels = labels(terms(modelfmla5)), ordered = TRUE)) %>%  #makes sure plot is maintains order of terms
  ggplot() +
  #geom_bar(aes(x = term, y = estimate), stat = "identity") +
  geom_pointrange(aes(x = term, ymin = estimate - 2 * std.error, ymax = estimate + 2 * std.error, y = estimate),
                  stat = "identity", fatten = 0.5) +
  facet_grid(rows = vars(.model)) +
  ylim(c(-0.1, 0.5)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

tidy(fit_loglin)
```

+ __Still to do: look up and determine whether fitting an ETS or 'exponential smoothing' model would make sense: https://otexts.com/fpp3/expsmooth.html__
+ __Still to do: try a multiplicative model (e.g. log linear)__
+ __Still to do: follow the Box-Jenkins style to find out how many past years to use, test for stationarity etc__
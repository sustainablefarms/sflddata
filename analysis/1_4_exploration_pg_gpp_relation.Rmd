---
title: "More Exploration of GPP and precipitation"
author: "Kassel Hingee"
date: "13/01/2020"
output: html_document
---

The following exploration occurs after fitting an additive linear model, and log-linear model for GPP. It uses learnings summarised in `1_3_3_model_fitting_pg_gpp.Rmd`.

+ correlation analysis, a variety of transforms and derivative precipitation infomration, would be useful for choosing predictors
+ using pre-built decomposition methods within R to explore break down too
+ exploring stationarity of GPP


```{r setup}
knitr::opts_chunk$set(echo = TRUE)
out <- lapply(c("sf", "tsibble", 'lubridate', "viridis",
                'ggplot2', 'tidyr', 'grid', 'gridExtra', 
                'feasts', 'dplyr', 'gtable', 'fable'),
       library, character.only = TRUE)
out <- lapply(paste0("../functions/", list.files("../functions/")), source)
```

```{r preparedata}
#load data and convert to tsibbles
load("../private/data/remote_sensed/pg_daily.Rdata")
pg_daily$times <- as_date(pg_daily$times)
pg <- pg_daily %>%
  pivot_longer(-times, names_to = "site", values_to = "pg") %>%
  as_tsibble(key = site, index = times)
load("../private/data/remote_sensed/gpp_8d.Rdata")
gpp <- gpp_8d %>%
  pivot_longer(-times, names_to = "site", values_to = "gpp") %>%
  as_tsibble(key = site, index = times)
pggpp <- as_tsibble(dplyr::full_join(pg, gpp, by = c("times", "site")), key = site, index = times)

#interpolate gpp
pggpp <- pggpp %>%
  mutate(yday = yday(times)) %>%
  group_by_key() %>% #key is site
  mutate(lininterp_gpp = zoo::na.approx(gpp, rule = 2, na.rm = FALSE)) %>% #rule 2 means edges are assigned last value
  ungroup()

#make sure sites are ordered alphabetically
pggpp <- pggpp %>%
  arrange(site) %>%
  mutate(site = factor(site, ordered = TRUE))

#extract alpha part of code
pggpp <- pggpp %>%
  mutate(farm = substr(site, 1, 4),
         sitenum = as.integer(substr(site, 5, 5)))
```


## Automatic Time Series Decompositions
Using interpolated values for all decompositions - so that it will not error.

In below:
+ the season window specifies how fast the seasonal component of the decomposition can vary
+ the trend window specifies how fast the trend can vary

```{r stl_decomposition_additive}
decomposition <- pggpp %>%
  filter(site %in% c("ARCH1", "BELL1")) %>%
  STL(lininterp_gpp ~ trend(5*8, degree = 1) + season("3 year", degree = 0))
decomposition %>% 
  autoplot()
```

Remainders are quite autocorrelated even with a trend term. Multiplicate might do better.


Multiplicative decompisition with STL
```{r stl_decomposition_additive}
decomposition <- pggpp %>%
  filter(site %in% c("ARCH1", "BELL1")) %>%
  STL(log(lininterp_gpp + 1) ~ trend(6*8, degree = 1) + season("1 year", degree = 1))
decomposition %>% 
  autoplot()
```
The remainders are about a 3rd of the season variation.

Something in between multiplicative and additive:
```{r stl_decomposition_additive}
decomposition <- pggpp %>%
  filter(site %in% levels(site)[c(1, 5, 9)]) %>%
  STL(box_cox(lininterp_gpp + 1, lambda = 0.5) ~ trend(5*8, degree = 1) + season("1 year", degree = 0))
decomposition %>% 
  autoplot()
```

Multiplicative decompisition with STL with outliers capped (really it would be better to delete but the code doesn't allow that)
```{r stl_decomposition_additive}
edges <- quantile(pggpp$gpp, probs = c(0.01, 0.99), na.rm = TRUE, names = TRUE)
decomposition <- pggpp %>%
  filter(site %in% c("ARCH1", "BELL1")) %>%
  mutate(lininterp_gpp = case_when(lininterp_gpp < edges[[1]] ~ edges[[1]],
                                   lininterp_gpp > edges[[2]] ~ edges[[2]],
                                   TRUE ~ lininterp_gpp)) %>%
  STL(log(lininterp_gpp +1) ~ trend(6*8, degree = 1) + season("1 year", degree = 1))
decomposition %>% 
  autoplot()
```

It is difficult to interpret much from this figure, nothing appears different to when outliers are not capped.

### Classical decomposition
Uses moving averages
```{r classicaldecomp}
pggpp %>%
  filter(sitenum == 1) %>% #keep only first site at each farm
  filter(farm %in% unique(farm)[1:10]) %>%
  classical_decomposition(lininterp_gpp ~ season("1 year"), type = "multiplicative") %>%
  autoplot()
```

The seasonal variation and the trend variation are both smaller than the remainder! 
Furthermore the remainders appear to be autocorellated - suggestions decomposition is missing systematic parts.
Interesting that the trend says roughly constant for a year over spring, for many of the years.

##  Correlation Between Precipitation Derivatives
It seems like precipitation has a maximum impact *once a place is very wet, more rain isn't going to make it grow faster*. This means that the effect of precipitation in the last month depends on the precipitation over the last 6 months (i.e. there is interaction). The effect will also interact with the GPP of that site of that particular day in past years.

 + Use cumulative-monthly precipitation (backwards in time?)
 + Use monthly precipitation with interactions between months?
 + Use seasonal residuals of precipitation?
 + Use interactions between cumulative precipitation and season, and past GPP?
 
### Add seasonal precipitation residuals
First attempt is to use STL decomposition (which is smoothing), which can't actually *predict* seasonal precipitation so could be bad use!
```{r seasonalprecipitation}
decomposepg <- pggpp %>%
  group_by_key() %>%
  STL(pg ~ season(period = "1 year", window = "periodic"), iterations = 3)
decomposepg <- decomposepg %>%
  inner_join(pggpp, by = NULL)
decomposepg %>%
  filter(sitenum == 1) %>% #keep only first site at each farm
  filter(farm %in% unique(farm)[c(1, 5, 10)]) %>%
  filter_index("2011") %>%
  ggplot() +
  facet_wrap(~ site) +
  geom_line(aes(x = times, y = trend + `season_1 year`), col = "blue") +
  geom_point(aes(x = times, y = pg), size = 0.1) 
```

Lets try an actual model! Zero-inflated distribution: Tweedie with 1 < p < 2.
First lets get experience looking at the histograms of the pg data and tweedie distributions.
```{r tweedieeg}
library(tweedie)
invisible(tweedie.plot(seq(0, 30, by = 0.1), mu = 0.2, phi = 0.5, power = 1.2))
```
```{r tweedieforpg}
prop0 <- mean(pggpp$pg == 0)
pggpp %>% 
  ggplot() +
  geom_histogram(aes(x = pg, y = stat(density) * (1 - prop0)), data = function(x) x %>% filter(pg > 0), bins = 30, col = "grey") +
  geom_density(aes(x = pg, y = stat(density) * (1 - prop0)), data = function(x) x %>% filter(pg > 0)) +
  geom_point(aes(x = 0, y = prop0)) +
  xlim(0, 40)
```


```{r fitgamwithtweedie_BELL1}
library(mgcv)
pgmodel <- gam(pg ~ s(yday, bs = "cc", k = 20), family = tw(),
             data = pggpp %>% filter(site == "BELL1"),
             knots = list(yday = c(0, 10)))
plot(pgmodel)
gam.check(pgmodel)
acf(pgmodel$residuals)
```

The QQ plot suggests that the distribution of observed residuals matches the assumption of a Tweedie distribution (with fitted p).
The ACF plot suggests some autocorrelation of level 1.

Given that the distribution of residuals is a non-symmetric distribution (Tweedie == gamma-poisson compound), then I wonder if using them makes sense for predicting gpp.

Trying using autocorrelation and the `p` found above.
```{r fitgamwithtweedie_BELL1}
library(mgcv)
pgmodel_AR1 <- gamm(pg ~ s(yday, bs = "cc", k = 20), family = Tweedie(p = 1.781, link = "log"),
             data = pggpp %>% filter(site == "BELL1"),
             correlation = corAR1(form = ~1),
             knots = list(yday = c(0, 10)))
plot(pgmodel_AR1$gam)
plot(pgmodel_AR1$lme)
acf(pgmodel_AR1$lme$residuals[, 1])
gam.check(pgmodel_AR1$gam)
acf(pgmodel_AR1$gam$residuals)
```

Fitting took a LONG time, and this just for a single site.
I expected the correlations of the residuals to drop, but they didn't.
Also I do not know what the piecewise-linear nature of the QQ plot means.

I've concluded that the seasonal-residual daily precipitation will not be very useful as the distribution around the seasonal precipitation is highly unsymmetric. The mean daily precipitation as fitted in the above models might be useful though.
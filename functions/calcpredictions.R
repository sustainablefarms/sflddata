library(runjags); library(dplyr); library(tidyr); library(tibble);

#' @title Predicted Probabilities
#' ** would be great to test these functions by monitoring z, p and mu.p in runjags (perhaps using hidden.monitor parameter)

#' @examples 
#' fit <- readRDS("./tmpdata/7_1_mcmcchain_20200424.rds")
#' fit <- add.summary(fit)
#' pDetection <- pdetect_indspeciesvisit_LVmarginal(fit, type = "median")
#' pOccupancy <- poccupy_indspecies_LVmarginal(fit, type = "median")

# Getting to the probability of detecting a species at a particular site
# marginal and otherwise too
#' @describeIn predictedprobabilities  
#'  For a point estimate of model parameters,
#'  for each species and each visit,
#'  computes the probability of detection ignoring results from other visits or other species,
#'  and assumes no knowledge of the latent variable values.
#' @param fit is a fitted runjags model
#' @param type is the type of point estimate to use. Currently on "median" is accepted. In future could be any point statistic generated by runjags::add.summary()
#' @param Xocc A matrix of occupancy coefficient, with each row corresponding to a ModelSite (i.e. a spatial location and year).
#'  If \code{NULL} the Xocc data saved in \code{fit} will be used.
#' @param Xobs A matrix of observation (detection) coefficients. Default is the observation coefficients saved in \code{fit}
#' @param ModelSite A list mapping each row in \code{Xobs} to the row in \code{Xocc} that represents the ModelSite visited.
#' @value A matrix of detection probabilities. Each row is a visit, corresponding to the rows in Xobs. Each column is a species.
pdetect_indspeciesvisit_LVmarginal <- function(fit, type = "median", Xocc = NULL, Xobs = NULL, ModelSite = NULL){
  if (!fit$summary.available){ fit <- add.summary(fit)}
  
  # Get ModelSite Occupany Predictions
  ModelSite.Occ.Pred <- poccupy_indspecies_LVmarginal(fit, type = type, Xocc = Xocc)
  
  # Get Detection Probabilities Assuming Occupied
  Visits.DetCond.Pred <- pdetect_condoccupied(fit, type = type, Xobs = Xobs)
 
  # combine with probability of occupancy 
  fitdata <- list.format(fit$data)
  if (is.null(ModelSite)){ModelSite <- fitdata$ObservedSite}
  
  ## Full Probability of Detection (marginalises across occupancy, detection and latent variables)
  Detection.Pred.Marg <- ModelSite.Occ.Pred[ModelSite, ] * Visits.DetCond.Pred
  return(Detection.Pred.Marg)
}

#' @describeIn predictedprobabilities  For a point estimate of model parameters, the probability of detecting a species for visits,
#' conditional on the species occupying the ModelSite.
#' @param fit is a fitted runjags model
#' @param type is the type of point estimate to use. Currently on "median" is accepted. In future could be any point statistic generated by runjags::add.summary()
#' @param Xobs A matrix of observation (detection) coefficients. Default is the observation coefficients saved in \code{fit}
#' @param ModelSite A list mapping each row in \code{Xobs} to the row in \code{Xocc} that represents the ModelSite visited.
#' @value A matrix of detection probabilities. Each row is a visit, corresponding to the rows in Xobs. Each column is a species.
pdetect_condoccupied <- function(fit, type = "median", Xobs = NULL){
  if (!fit$summary.available){ fit <- add.summary(fit)}
  fitdata <- list.format(fit$data)
  
  # build list of point estimates
  if (type == "median"){
    theta = fit$summary$quantiles[, "50%"]
  }
  
  ## v.b (detection coefficients)
  v.b <- bugsvar2array(theta, "v.b", 1:fitdata$n, 1:fitdata$Vobs) # rows are species, columns are observation (detection) covariates
 
  ## Get observation covariates 
  if (is.null(Xobs)){Xobs <- fitdata$Xobs}
  
  ## Probability of Detection, assuming occupied
  Detection.LinPred <- Xobs %*% t(v.b)
  Detection.Pred <- exp(Detection.LinPred) / (exp(Detection.LinPred) + 1)   #this is the inverse logit function
  
  return(Detection.Pred)
}

#' @describeIn predictedprobabilities  
#'  For a point estimate of model parameters,
#'  for each species,
#'  computes the probability of the species occupying ModelSites, ignoring other species,
#'  and assuming no knowledge of the latent variable values.
#' @param fit is a fitted runjags model
#' @param type is the type of point estimate to use. Currently on "median" is accepted. In future could be any point statistic generated by runjags::add.summary()
#' @param Xocc A matrix of occupancy coefficient, with each row corresponding to a ModelSite (i.e. a spatial location and year).
#'  If \code{NULL} the Xocc data saved in \code{fit} will be used.
#' @value A matrix of occupany probabilities. Each row is a ModelSite, corresponding to the rows in Xocc. Each column is a species.
poccupy_indspecies_LVmarginal <- function(fit, type = "median", Xocc = NULL){
  if (!fit$summary.available){ fit <- add.summary(fit)}
  fitdata <- list.format(fit$data)
  # build arrays of point estimates
  if (type == "median"){
    theta = fit$summary$quantiles[, "50%"]
  }
  ## u.b (occupancy coefficients)
  u.b <- bugsvar2array(theta, "u.b", 1:fitdata$n, 1:fitdata$Vocc) # rows are species, columns are occupancy covariates
  
  if (is.null(Xocc)){Xocc <- fitdata$Xocc}
  
  ## Probability of Site Occupancy
  ModelSite.Occ.LinPred <- Xocc %*% t(u.b) #rows are ModelSites, columns are species
  ModelSite.Occ.Pred <- 1 - pnorm(-ModelSite.Occ.LinPred, mean = 0)
  
  return(ModelSite.Occ.Pred)
}

#' @describeIn predictedprobabilities For converting values for array-valued parameters from the bugs variable format to a matrix
#' @param values is a list of values named according to the bugs variables names
#' @param varname is the desired variable name (e.g. 'u.b')
#' @param rowidx is a list of rows to extract, by number
#' @param colidx is a list of columns to extract, by number
bugsvar2array <- function(values, varname, rowidx, colidx){
  idx <- expand.grid(row = rowidx, col = colidx)
  values.long <- cbind(Value = values[paste0(varname, "[",idx$row, ",", idx$col, "]")], idx)
  value <- values.long %>%
    pivot_wider(values_from = Value,
                names_from = col) %>%
    column_to_rownames(var = "row") %>%
    as.matrix()
  return(value)
}

library(runjags); library(dplyr); library(tidyr); library(tibble);

#' @title Predicted Probabilities
#' ** would be great to test these functions by monitoring z, p and mu.p in runjags (perhaps using hidden.monitor parameter)

#' @examples 
#' fit <- readRDS("./tmpdata/7_1_mcmcchain_20200424.rds")
#' fit <- add.summary(fit)
#' pDetection <- pdetect_indspeciesvisit_LVmarginal(fit, type = "median")
#' pOccupancy <- poccupy_indspecies_LVmarginal(fit, type = "median")

# Getting to the probability of detecting a species at a particular site
# marginal and otherwise too
#' @describeIn predictedprobabilities  
#'  For a point estimate of model parameters,
#'  for each species and each visit,
#'  computes the probability of detection ignoring results from other visits or other species,
#'  and assumes no knowledge of the latent variable values.
#' @param fit is a fitted runjags model
#' @param type is the type of point estimate to use. Currently on "median" is accepted. In future could be any point statistic generated by runjags::add.summary()
#' @param Xocc A matrix of occupancy coefficient, with each row corresponding to a ModelSite (i.e. a spatial location and year).
#'  If \code{NULL} the Xocc data saved in \code{fit} will be used.
#' @param Xobs A matrix of observation (detection) coefficients. Default is the observation coefficients saved in \code{fit}
#' @param ModelSite A list mapping each row in \code{Xobs} to the row in \code{Xocc} that represents the ModelSite visited.
#' @value A matrix of detection probabilities. Each row is a visit, corresponding to the rows in Xobs. Each column is a species.
pdetect_indspeciesvisit_LVmarginal <- function(fit, type = "median", Xocc = NULL, Xobs = NULL, ModelSite = NULL){
  if (!fit$summary.available){ fit <- add.summary(fit)}
  
  # Get ModelSite Occupany Predictions
  ModelSite.Occ.Pred <- poccupy_indspecies_LVmarginal(fit, type = type, Xocc = Xocc)
  
  # Get Detection Probabilities Assuming Occupied
  Visits.DetCond.Pred <- pdetect_condoccupied(fit, type = type, Xobs = Xobs)
 
  # combine with probability of occupancy 
  fitdata <- list.format(fit$data)
  if (is.null(ModelSite)){
    if ("ObservedSite" %in% names(fitdata)){ModelSite <- fitdata$ObservedSite} #to enable calculation on the early fitted objects with different name
    if ("ModelSite" %in% names(fitdata)){ModelSite <- fitdata$ModelSite}
  }
  
  ## Full Probability of Detection (marginalises across occupancy, detection and latent variables)
  Detection.Pred.Marg <- ModelSite.Occ.Pred[ModelSite, ] * Visits.DetCond.Pred
  return(Detection.Pred.Marg)
}

#' @describeIn predictedprobabilities  
#'  For a point estimate of model parameters,
#'  for each species and each visit,
#'  computes the probability of detection ignoring results from other visits,
#'  and conditional on estimated latent variable values.
pdetect_indvisit_condLV <- function(fit, type = "median", Xocc = NULL, Xobs = NULL, ModelSite = NULL){
  if (!fit$summary.available){ fit <- add.summary(fit)}
  
  # Get ModelSite Occupany Predictions
  ModelSite.Occ.Pred <- poccupy_species_condLV(fit, type = type, Xocc = Xocc)
  
  # Get Detection Probabilities Assuming Occupied
  Visits.DetCond.Pred <- pdetect_condoccupied(fit, type = type, Xobs = Xobs)
  
  # combine with probability of occupancy 
  fitdata <- list.format(fit$data)
  if (is.null(ModelSite)){
    if ("ObservedSite" %in% names(fitdata)){ModelSite <- fitdata$ObservedSite} #to enable calculation on the early fitted objects with different name
    if ("ModelSite" %in% names(fitdata)){ModelSite <- fitdata$ModelSite}
  }
  
  ## Full Probability of Detection (marginalises across occupancy, detection and latent variables)
  Detection.Pred.Marg <- ModelSite.Occ.Pred[ModelSite, ] * Visits.DetCond.Pred
  return(Detection.Pred.Marg)
}

#' @describeIn predictedprobabilities  For a point estimate of model parameters, the probability of detecting a species for visits,
#' conditional on the species occupying the ModelSite.
#' @param fit is a fitted runjags model
#' @param type is the type of point estimate to use. Currently on "median" is accepted. In future could be any point statistic generated by runjags::add.summary()
#' @param Xobs A matrix of observation (detection) coefficients. Default is the observation coefficients saved in \code{fit}
#' @param ModelSite A list mapping each row in \code{Xobs} to the row in \code{Xocc} that represents the ModelSite visited.
#' @value A matrix of detection probabilities. Each row is a visit, corresponding to the rows in Xobs. Each column is a species.
pdetect_condoccupied <- function(fit, type = "median", Xobs = NULL){
  if (!fit$summary.available){ fit <- add.summary(fit)}
  fitdata <- list.format(fit$data)
  
  # build list of point estimates
  if (type == "median"){
    theta = fit$summary$quantiles[, "50%"]
  }
  
  ## v.b (detection coefficients)
  v.b <- bugsvar2array(theta, "v.b", 1:fitdata$n, 1:fitdata$Vobs)[,,1] # rows are species, columns are observation (detection) covariates
 
  ## Get observation covariates 
  if (is.null(Xobs)){Xobs <- fitdata$Xobs}
  
  ## Probability of Detection, assuming occupied
  Detection.LinPred <- Xobs %*% t(v.b)
  Detection.Pred <- exp(Detection.LinPred) / (exp(Detection.LinPred) + 1)   #this is the inverse logit function
  
  return(Detection.Pred)
}

#' @describeIn predictedprobabilities  
#'  For a point estimate of model parameters,
#'  for each species,
#'  computes the probability of the species occupying ModelSites, ignoring other species,
#'  and assuming no knowledge of the latent variable values.
#' @param fit is a fitted runjags model
#' @param type is the type of point estimate to use. Currently on "median" is accepted. In future could be any point statistic generated by runjags::add.summary()
#' @param Xocc A matrix of occupancy coefficient, with each row corresponding to a ModelSite (i.e. a spatial location and year).
#'  If \code{NULL} the Xocc data saved in \code{fit} will be used.
#' @value A matrix of occupany probabilities. Each row is a ModelSite, corresponding to the rows in Xocc. Each column is a species.
poccupy_indspecies_LVmarginal <- function(fit, type = "median", Xocc = NULL){
  if (!fit$summary.available){ fit <- add.summary(fit)}
  fitdata <- list.format(fit$data)
  # build arrays of point estimates
  if (type == "median"){
    theta = fit$summary$quantiles[, "50%"]
  }
  ## u.b (occupancy coefficients)
  u.b <- bugsvar2array(theta, "u.b", 1:fitdata$n, 1:fitdata$Vocc)[,,1] # rows are species, columns are occupancy covariates
  
  if (is.null(Xocc)){Xocc <- fitdata$Xocc}
  
  ## Probability of Site Occupancy
  ModelSite.Occ.LinPred <- Xocc %*% t(u.b) #rows are ModelSites, columns are species
  ModelSite.Occ.Pred <- 1 - pnorm(-ModelSite.Occ.LinPred, mean = 0)
  
  return(ModelSite.Occ.Pred)
}

#' @describeIn predictedprobabilities  
#'  For a point estimate of model parameters,
#'  for each species,
#'  computes the probability of the species occupying ModelSites
#'  given estimated latent variable values for each site.
poccupy_species_condLV <- function(fit, type = "median", Xocc = NULL){
  if (!fit$summary.available){ fit <- add.summary(fit)}
  fitdata <- list.format(fit$data)
  # build arrays of point estimates
  if (type == "median"){
    theta = fit$summary$quantiles[, "50%"]
  }
  ## u.b (occupancy coefficients)
  u.b <- bugsvar2array(theta, "u.b", 1:fitdata$n, 1:fitdata$Vocc)[,,1] # rows are species, columns are occupancy covariates
  
  ## LV values
  LV <- bugsvar2array(theta, "LV", 1:fitdata$J, 1:fitdata$nlv)[,,1] # rows are model sites, columns are latent variables
  ## LV loadings
  lv.coef <- bugsvar2array(theta, "lv.coef", 1:fitdata$n, 1:fitdata$nlv)[,,1] # rows are species columns are occupancy covariates
  sd_u_condlv <- sqrt(1 - rowSums(lv.coef^2))
  
  if (is.null(Xocc)){Xocc <- fitdata$Xocc}
  
  ## Probability of Site Occupancy
  ModelSite.Occ.eta <- Xocc %*% t(u.b) + #rows are ModelSites, columns are species
    LV %*% t(lv.coef)
  # Make u standard deviations equal to 1 by dividing other values by sd
  # P(u < -ModelSite.Occ.eta) = P(u / sd < -ModelSite.Occ.eta / sd) = P(z < -ModelSite.Occ.eta / sd)
  ModelSite.Occ.eta_standardised <- Rfast::eachrow(ModelSite.Occ.eta, sd_u_condlv, oper = "/") 
  ModelSite.Occ.Pred.CondLV <- 1 - pnorm(-ModelSite.Occ.eta_standardised, mean = 0,
                                         sd = 1)
  
  return(ModelSite.Occ.Pred.CondLV)
}

#' @describeIn predictedprobabilities For converting values for array-valued parameters from the bugs variable format to a matrix
#' @param values is a list of values named according to the bugs variables names
#' @param varname is the desired variable name (e.g. 'u.b')
#' @param rowidx is a list of rows to extract, by number
#' @param colidx is a list of columns to extract, by number
bugsvar2array <- function(values, varname, rowidx, colidx){
  if (is.vector(values)) {
    values <- matrix(values, nrow = 1, dimnames = list(row = NULL, col = names(values)))
  }
  idx <- expand.grid(row = rowidx, col = colidx)
  bugsnames <- paste0(varname, "[",idx$row, ",", idx$col, "]") #order matters, expand.grid must go through rows and then columns
  value <- array(t(values[, bugsnames]), 
                 dim = c(length(rowidx), length(colidx), nrow(values)), 
                 dimnames = list(row = rowidx, col = colidx, draw = 1:nrow(values)))
  return(value)
}

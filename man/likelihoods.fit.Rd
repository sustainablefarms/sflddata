% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/likelihood.R
\name{lppd.newdata}
\alias{lppd.newdata}
\alias{likelihoods.fit}
\alias{likelihood_joint_marginal.ModelSite}
\alias{likelihood_joint_marginal.ModelSite.theta}
\title{Computing Likelihoods for Occupancy Detection Models}
\usage{
lppd.newdata(
  fit,
  Xocc,
  yXobs,
  ModelSite,
  chains = 1,
  numlvsims = 1000,
  cl = NULL
)

likelihoods.fit(
  fit,
  Xocc = NULL,
  yXobs = NULL,
  ModelSite = NULL,
  chains = NULL,
  numlvsims = 1000,
  cl = NULL
)

likelihood_joint_marginal.ModelSite(
  Xocc,
  Xobs,
  y,
  u.b_arr,
  v.b_arr,
  lv.coef_arr,
  lvsim
)

likelihood_joint_marginal.ModelSite.theta(
  Xocc,
  Xobs,
  y,
  u.b,
  v.b,
  lv.coef,
  lvsim
)
}
\arguments{
\item{Xocc}{A matrix of occupancy covariates. Must have a single row. Columns correspond to covariates.}

\item{chains}{is a vector indicator which mcmc chains to extract draws from. If NULL then all chains used.}

\item{numlvsims}{the number of simulated latent variable values to use for computing likelihoods}

\item{cl}{a cluster created by parallel::makeCluster()}

\item{Xobs}{A matrix of detection covariates, each row is a visit.}

\item{y}{A matrix of detection data for a given model site. 1 corresponds to detected. Each row is visit, each column is a species.}

\item{u.b_arr}{Occupancy covariate loadings. Each row is a species, each column an occupancy covariate, each layer (dim = 3) is a draw}

\item{v.b_arr}{Detection covariate loadings. Each row is a species, each column an detection covariate, each layer (dim = 3) is a draw}

\item{lv.coef_arr}{LV loadings. Each row is a species, each column a LV, each layer (dim = 3) is a draw}

\item{lvsim}{A matrix of simulated LV values. Columns correspond to latent variables, each row is a simulation}

\item{u.b}{A vector of model parameters, labelled according to the BUGS labelling convention seen in runjags}

\item{v.b}{Covariate loadings. Each row is a species, each column a detection covariate}

\item{lv.coef}{Loadings for the latent variables. Each row is a species, each column corresponds to a LV.}

\item{data_i}{A row of a data frame created by \code{prep_data_by_modelsite}. Each row contains data for a single ModelSite.}
}
\value{
\code{lppd.newdata} returns a list with components
lpds: a list of the log likelihood of the observations for each ModelSite in the supplied data
lppd: the computed log pointwise predictive density (sum of the lpds). This is equation (5) in Gelman et al 2014

\code{likelihoods.fit} returns a matrix. Each row corresponds to a draw of the parameters from the posterior. Each column to a ModelSite
Compute the likelihoods of each ModelSite's observations given each draw of parameters in the posterior.
}
\description{
Computing Likelihoods for Occupancy Detection Models
}
\details{
Any predictinve accuracy measure requires a choice of
\enumerate{
\item the part of the model that is considered the 'likelihood' and
\item factorisation of the likelihood into 'data points' \link{Vehtari 2017}
}

On 1: New data will look like a new location or visit for a new season in our exisitng region, and observing only the species included in the model.
This means we have zero knowledge of the latent variable value at the new ModelSite. This means likelihood:
*  conditional on the covariates u.b and v.b (not using the fitted values of mu.u.b, tau.u.b etc)
*  is conditional on the lv.coef values of each species
*  is conditional on the latent variable value for (each) new ModelSite being drawn from a standard Gaussian distribution.

On 2: Factoring the likelihood using the inbuilt independence properties of the model means
a single 'data point' is all the data for all visits of a single ModelSite.
The likelihood could also be partitioned by each visit, but then data points are dependent (they have the same occupancy value).

The output of \code{\link[=likelihoods.fit]{likelihoods.fit()}} can be easily passed to \code{\link[loo:waic]{loo::waic()}} and \code{\link[loo:loo]{loo::loo()}}.
}
\section{Functions}{
\itemize{
\item \code{lppd.newdata}: Compute the log pointwise posterior density of new (out-of-sample) data

\item \code{likelihoods.fit}: Compute the likelihood of observations at each ModelSites. At data in the fitted model, or on new data supplied.

\item \code{likelihood_joint_marginal.ModelSite}: Compute the joint-species LV-marginal likelihood for a ModelSite

\item \code{likelihood_joint_marginal.ModelSite.theta}: Compute the joint-species LV-marginal likelihood for a ModelSite
}}

\examples{
# simulate data
covars <- simulate_covar_data(nsites = 50, nvisitspersite = 2)
y <- simulate_iid_detections(3, nrow(covars$Xocc))

fittedmodel <- run.detectionoccupancy(
  Xocc = covars$Xocc,
  yXobs = cbind(covars$Xobs, y),
  species = colnames(y),
  ModelSite = "ModelSite",
  OccFmla = "~ UpSite + Sine1",
  ObsFmla = "~ UpVisit + Step",
  nlv = 2,
  MCMCparams = list(n.chains = 1, adapt = 0, burnin = 0, sample = 3, thin = 1)
)

# run likelihood computations, waic, and psis-loo
insamplell <- likelihoods.fit(fittedmodel)
waic <- loo::waic(log(insamplell))
looest <- loo::loo(log(insamplell), cores = 2)



outofsample_covars <- simulate_covar_data(nsites = 10, nvisitspersite = 2)
outofsample_y <- simulate_iid_detections(3, nrow(outofsample_covars$Xocc))
outofsample_lppd <- lppd.newdata(fittedmodel,
             Xocc = outofsample_covars$Xocc,
             yXobs = cbind(outofsample_covars$Xobs, outofsample_y),
             ModelSite = "ModelSite")

# Recommend using multiple cores:
cl <- parallel::makeCluster(2)
insamplell <- likelihoods.fit(fittedmodel, cl = cl)

outofsample_lppd <- lppd.newdata(fittedmodel,
                                 Xocc = outofsample_covars$Xocc,
                                 yXobs = cbind(outofsample_covars$Xobs, outofsample_y),
                                 ModelSite = "ModelSite",
                                 cl = cl)
parallel::stopCluster(cl)
}
\references{
A. Vehtari, A. Gelman, and J. Gabry, "Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC," Stat Comput, vol. 27, pp. 1413-1432, Sep. 2017, doi: 10.1007/s11222-016-9696-4.
}

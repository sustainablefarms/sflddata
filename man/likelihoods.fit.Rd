% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/likelihood.R
\name{lppd.newdata}
\alias{lppd.newdata}
\alias{likelihoods.fit}
\alias{prep_data_by_modelsite.newdata}
\alias{prep_data_by_modelsite}
\alias{likelihood_joint_marginal.ModelSiteDataRow}
\alias{likelihood_joint_marginal.ModelSite.theta}
\title{Computing Likelihoods for Occupancy Detection Models}
\usage{
lppd.newdata(
  fit,
  Xocc,
  yXobs,
  ModelSite,
  chains = 1,
  numlvsims = 1000,
  cl = NULL
)

likelihoods.fit(
  fit,
  Xocc = NULL,
  yXobs = NULL,
  ModelSite = NULL,
  chains = 1,
  numlvsims = 1000,
  cl = NULL
)

prep_data_by_modelsite.newdata(fit, Xocc, yXobs, ModelSite)

prep_data_by_modelsite(Xocc, Xobs, y, ModelSite, outformat = "list")

likelihood_joint_marginal.ModelSiteDataRow(data_i, draws, lvsim, cl = NULL)

likelihood_joint_marginal.ModelSite.theta(Xocc, Xobs, y, theta, lvsim)
}
\arguments{
\item{fit}{is an object created by run.detectionoccupany}

\item{Xocc}{A matrix of occupancy covariates. Must have a single row. Columns correspond to covariates.}

\item{yXobs}{A dataframe of species observations (1 or 0) and covariates related to observations. One row per visit.
Each column is either a covariate or a species.
Must also include the ModelSiteVars columns to uniquely specify ModelSite.}

\item{ModelSite}{A list of column names in y, Xocc and Xobs that uniquely specify the ModelSite. Can be simply a ModelSite index}

\item{chains}{is a vector indicator which mcmc chains to extract draws from}

\item{numlvsims}{the number of simulated latent variable values to use for computing likelihoods}

\item{cl}{a cluster created by parallel::makeCluster()}

\item{Xobs}{A matrix of detection covariates, each row is a visit.}

\item{y}{A matrix of detection data for a given model site. 1 corresponds to detected. Each row is visit, each column is a species.}

\item{data_i}{A row of a data frame created by \code{prep_data_by_modelsite}. Each row contains data for a single ModelSite.}

\item{draws}{A large matrix. Each column is a model parameter, with array elements named according to the BUGS naming convention.
Each row of \code{draws} is a simulation from the posterior.}

\item{lvsim}{A matrix of simulated LV values. Columns correspond to latent variables, each row is a simulation}

\item{theta}{A vector of model parameters, labelled according to the BUGS labelling convention seen in runjags}
}
\value{
\code{lppd.newdata} returns a list with components
lpds: a list of the log likelihood of the observations for each ModelSite in the supplied data
lppd: the computed log pointwise predictive density (sum of the lpds). This is equation (5) in Gelman et al 2014

\code{likelihoods.fit} returns a matrix. Each row corresponds to a draw of the parameters from the posterior. Each column to a ModelSite
Compute the likelihoods of each ModelSite's observations given each draw of parameters in the posterior.

An array with each row a model site and elements that are dataframes for each of Xocc, Xobs, y.
}
\description{
Computing Likelihoods for Occupancy Detection Models
}
\details{
Any predictinve accuracy measure requires a choice of
\enumerate{
\item the part of the model that is considered the 'likelihood' and
\item factorisation of the likelihood into 'data points' \link{Vehtari 2017}
}

On 1: New data will look like a new location or visit for a new season in our exisitng region, and observing only the species included in the model.
This means we have zero knowledge of the latent variable value at the new ModelSite. This means likelihood:
*  conditional on the covariates u.b and v.b (not using the fitted values of mu.u.b, tau.u.b etc)
*  is conditional on the lv.coef values of each species
*  is conditional on the latent variable value for (each) new ModelSite being drawn from a standard Gaussian distribution.

On 2: Factoring the likelihood using the inbuilt independence properties of the model means
a single 'data point' is all the data for all visits of a single ModelSite.
The likelihood could also be partitioned by each visit, but then data points are dependent (they have the same occupancy value).

The output of \code{\link[=likelihoods.fit]{likelihoods.fit()}} can be easily passed to \code{\link[loo:waic]{loo::waic()}} and \code{\link[loo:loo]{loo::loo()}}.
}
\section{Functions}{
\itemize{
\item \code{lppd.newdata}: Compute the log pointwise posterior density of new (out-of-sample) data

\item \code{likelihoods.fit}: Compute the likelihood of observations at each ModelSites. At data in the fitted model, or on new data supplied.

\item \code{prep_data_by_modelsite.newdata}: Given a fitted model, and input data, prepare the data for computing likelihood

\item \code{prep_data_by_modelsite}: Given data prepared by prep.data (or prep_new_data),
convert to an array with each row a model site and elements that each a dataframe for
the Xocc, Xobs, y. ModelSite must be a vector that indicates the row in Xocc corresponding to the observation in Xobs

\item \code{likelihood_joint_marginal.ModelSiteDataRow}: Compute the joint-species LV-marginal likelihood for a ModelSite

\item \code{likelihood_joint_marginal.ModelSite.theta}: Compute the joint-species LV-marginal likelihood for a ModelSite
}}

\examples{
# simulate data
covars <- simulate_covar_data(nsites = 50, nvisitspersite = 2)
y <- simulate_iid_detections(3, nrow(covars$Xocc))

fittedmodel <- run.detectionoccupany(
  Xocc = covars$Xocc,
  yXobs = cbind(covars$Xobs, y),
  species = colnames(y),
  ModelSite = "ModelSite",
  OccFmla = "~ UpSite + Sine1",
  ObsFmla = "~ UpVisit + Step",
  nlv = 2,
  MCMCparams = list(n.chains = 1, adapt = 0, burnin = 0, sample = 3, thin = 1)
)

# run likelihood computations, waic, and psis-loo
insamplell <- likelihoods.fit(fittedmodel)
waic <- loo::waic(log(insamplell))
looest <- loo::loo(log(insamplell), cores = 2)



outofsample_covars <- simulate_covar_data(nsites = 10, nvisitspersite = 2)
outofsample_y <- simulate_iid_detections(3, nrow(outofsample_covars$Xocc))
outofsample_lppd <- lppd.newdata(fittedmodel,
             Xocc = outofsample_covars$Xocc,
             yXobs = cbind(outofsample_covars$Xobs, outofsample_y),
             ModelSite = "ModelSite")

# Recommend using multiple cores:
cl <- parallel::makeCluster(2)
insamplell <- likelihoods.fit(fittedmodel, cl = cl)

outofsample_lppd <- lppd.newdata(fittedmodel,
                                 Xocc = outofsample_covars$Xocc,
                                 yXobs = cbind(outofsample_covars$Xobs, outofsample_y),
                                 ModelSite = "ModelSite",
                                 cl = cl)
parallel::stopCluster(cl)
}
\references{
A. Vehtari, A. Gelman, and J. Gabry, "Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC," Stat Comput, vol. 27, pp. 1413-1432, Sep. 2017, doi: 10.1007/s11222-016-9696-4.
}
